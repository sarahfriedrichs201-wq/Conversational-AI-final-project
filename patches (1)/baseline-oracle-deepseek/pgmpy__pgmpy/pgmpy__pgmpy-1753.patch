diff --git a/pgmpy/utils/utils.py b/pgmpy/utils/utils.py
--- a/pgmpy/utils/utils.py
+++ b/pgmpy/utils/utils.py
@@ -1,4 +1,5 @@
 import itertools
+import warnings
 from collections import defaultdict
 
 import numpy as np
@@ -6,6 +7,7 @@
 from scipy.special import gammaln
 
 from pgmpy.extern import tabulate
+from pgmpy.global_vars import SHOW_PROGRESS
 
 
 def sample_discrete(values, weights, size=1, seed=None):
@@ -103,3 +105,103 @@
         return np.exp(logp)
     else:
         return logp
+
+
+def discretize(data, cardinality, labels=dict(), method="rounding"):
+    """
+    Discretizes a given continuous dataset.
+
+    Parameters
+    ----------
+    data: pandas.DataFrame
+        The dataset to discretize. All columns must have continuous values.
+
+    cardinality: dict
+        A dictionary of the form (str: int) representing the number of bins
+        to create for each of the variables.
+
+    labels: dict (default: {})
+        A dictionary of the form (str: list) representing the label names for
+        each variable in the discretized dataframe.
+
+    method: rounding or quantile (default: "rounding")
+        If rounding, equal width bins are created and data is discretized into these bins.
+        Refer pandas.cut for more details.
+        If quantile, creates bins such that each bin has an equal number of datapoints.
+        Refer pandas.qcut for more details.
+
+    Examples
+    --------
+    >>> import numpy as np
+    >>> import pandas as pd
+    >>> from pgmpy.utils import discretize
+    >>> rng = np.random.default_rng(42)
+    >>> X = rng.standard_normal(1000)
+    >>> Y = 0.2 * X + rng.standard_normal(1000)
+    >>> Z = 0.4 * X + 0.5 * Y + rng.standard_normal(1000)
+    >>> df = pd.DataFrame({"X": X, "Y": Y, "Z": Z})
+    >>> df_disc = discretize(df, cardinality={'X': 3, 'Y': 3, 'Z': 3},
+    ...                      labels={'X': ['low', 'mid', 'high'],
+    ...                              'Y': ['low', 'mid', 'high'],
+    ...                              'Z': ['low', 'mid', 'high']})
+    >>> df_disc.head()
+         X    Y    Z
+    0   mid  mid  mid
+    1   mid  mid  low
+    2   mid  mid  mid
+    3  high  mid  mid
+    4   low  mid  low
+
+    Returns
+    -------
+    pandas.DataFrame: A discretized dataframe.
+    """
+    import pandas as pd
+
+    if not isinstance(data, pd.DataFrame):
+        raise TypeError("data must be a pandas.DataFrame")
+
+    if not isinstance(cardinality, dict):
+        raise TypeError("cardinality must be a dictionary")
+
+    if not isinstance(labels, dict):
+        raise TypeError("labels must be a dictionary")
+
+    # Check that all columns in cardinality are present in data
+    missing_cols = set(cardinality.keys()) - set(data.columns)
+    if missing_cols:
+        raise ValueError(
+            f"Columns {missing_cols} in cardinality not found in data columns"
+        )
+
+    # Check that all columns in labels are present in data
+    if labels:
+        missing_label_cols = set(labels.keys()) - set(data.columns)
+        if missing_label_cols:
+            raise ValueError(
+                f"Columns {missing_label_cols} in labels not found in data columns"
+            )
+
+    # Check that method is valid
+    if method not in ["rounding", "quantile"]:
+        raise ValueError("method must be either 'rounding' or 'quantile'")
+
+    discretized_data = pd.DataFrame()
+
+    for col in data.columns:
+        if col in cardinality:
+            n_bins = cardinality[col]
+            if method == "rounding":
+                discretized_col = pd.cut(data[col], bins=n_bins, labels=False)
+            else:  # method == "quantile"
+                discretized_col = pd.qcut(data[col], q=n_bins, labels=False, duplicates='drop')
+            
+            # Convert to labels if provided
+            if col in labels:
+                label_list = labels[col]
+                if len(label_list) != n_bins:
+                    warnings.warn(f"Number of labels for column {col} ({len(label_list)}) does not match cardinality ({n_bins}). Using integer labels.")
+                else:
+                    discretized_col = discretized_col.map(lambda x: label_list[int(x)] if not pd.isna(x) else x)
+            discretized_data[col] = discretized_col
+
+    return discretized_data
diff --git a/pgmpy/utils/__init__.py b/pgmpy/utils/__init__.py
--- a/pgmpy/utils/__init__.py
+++ b/pgmpy/utils/__init__.py
@@ -1,4 +1,5 @@
 from pgmpy.utils.math import log_likelihood_score
+from pgmpy.utils.utils import discretize
 from pgmpy.utils.sampling import sample_discrete
 from pgmpy.utils.state_name import StateNameDecorator
 
@@ -6,4 +7,5 @@
     "log_likelihood_score",
     "sample_discrete",
     "StateNameDecorator",
+    "discretize",
 ]
