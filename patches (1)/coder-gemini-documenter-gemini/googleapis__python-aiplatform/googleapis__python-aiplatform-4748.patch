diff --git a/CHANGELOG.md b/CHANGELOG.md
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,3 +1,8 @@
 ## [Unreleased]
 
+### Chores
+
+* chore: Add vector search samples for filtering, crowding, and hybrid queries ([#XXXX](https://github.com/googleapis/python-aiplatform/issues/XXXX))
+
 ## [1.53.0] - 2024-06-18
 
 ### Features
diff --git a/samples/model-builder/vector_search/vector_search_find_neighbors_sample.py b/samples/model-builder/vector_search/vector_search_find_neighbors_sample.py
--- a/samples/model-builder/vector_search/vector_search_find_neighbors_sample.py
+++ b/samples/model-builder/vector_search/vector_search_find_neighbors_sample.py
@@ -1,13 +1,19 @@
 import argparse
+import logging
 from typing import List
 
 from google.cloud import aiplatform
 from google.cloud.aiplatform.matching_engine.matching_engine_index_endpoint import (
     MatchNeighbor,
     Namespace,
     NumericNamespace,
+    QueryMode, # Required for HYBRID query mode
 )
 
+# Configure logging for better visibility during sample execution
+logging.basicConfig(level=logging.INFO)
+_LOGGER = logging.getLogger(__name__)
+
 
 # [START aiplatform_sdk_vector_search_find_neighbors_sample]
 def vector_search_find_neighbors_sample(
@@ -44,6 +50,108 @@
     return response
 # [END aiplatform_sdk_vector_search_find_neighbors_sample]
 
+
+# [START aiplatform_sdk_vector_search_find_neighbors_hybrid_sample]
+def vector_search_find_neighbors_hybrid_queries(
+    project: str,
+    location: str,
+    index_endpoint_name: str,
+    deployed_index_id: str,
+    num_neighbors: int,
+) -> List[List[MatchNeighbor]]:
+    """Query the vector search index using example hybrid queries.
+
+    Args:
+        project (str): Required. Project ID
+        location (str): Required. The region name
+        index_endpoint_name (str): Required. Index endpoint to run the query
+            against.
+        deployed_index_id (str): Required. The ID of the DeployedIndex to run
+            the queries against.
+        num_neighbors (int): Required. The number of neighbors to return.
+
+    Returns:
+        List[List[aiplatform.matching_engine.matching_engine_index_endpoint.MatchNeighbor]] - A list of nearest neighbors for each query.
+    """
+    aiplatform.init(project=project, location=location)
+
+    _LOGGER.info(
+        f"Finding neighbors with hybrid queries for index endpoint: {index_endpoint_name}, "
+        f"deployed index ID: {deployed_index_id}, num_neighbors: {num_neighbors}"
+    )
+
+    index_endpoint = aiplatform.MatchingEngineIndexEndpoint(
+        index_endpoint_name=index_endpoint_name
+    )
+
+    # Define example queries. These should be representative vectors
+    # matching the dimensionality of your index.
+    # For a real scenario, these would come from an embedding model.
+    queries = [
+        [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0],  # Example query 1
+        [1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1],  # Example query 2
+    ]
+    # NOTE: Adjust the dimensionality of these example queries to match your actual index.
+    # If your index has a different dimensionality (e.g., 768 for common embeddings),
+    # these example vectors must be adjusted accordingly.
+
+    response = index_endpoint.find_neighbors(
+        deployed_index_id=deployed_index_id,
+        queries=queries,
+        num_neighbors=num_neighbors,
+        query_mode=QueryMode.HYBRID,
+    )
+
+    _LOGGER.info("Hybrid query results:")
+    for i, query_results in enumerate(response):
+        _LOGGER.info(f"  Query {i+1} results:")
+        for neighbor in query_results:
+            _LOGGER.info(f"    ID: {neighbor.id}, Distance: {neighbor.distance}")
+
+    return response
+# [END aiplatform_sdk_vector_search_find_neighbors_hybrid_sample]
+
+
+# [START aiplatform_sdk_vector_search_find_neighbors_filtering_crowding_sample]
+def vector_search_find_neighbors_filtering_crowding(
+    project: str,
+    location: str,
+    index_endpoint_name: str,
+    deployed_index_id: str,
+    queries: List[List[float]],
+    num_neighbors: int,
+    filter: List[Namespace],
+    numeric_filter: List[NumericNamespace],
+    per_crowding_attribute_neighbor_count: int,
+) -> List[List[MatchNeighbor]]:
+    """Query the vector search index with filtering and crowding.
+
+    Args:
+        project (str): Required. Project ID
+        location (str): Required. The region name
+        index_endpoint_name (str): Required. Index endpoint to run the query
+            against.
+        deployed_index_id (str): Required. The ID of the DeployedIndex to run
+            the queries against.
+        queries (List[List[float]]): Required. A list of queries. Each query is
+            a list of floats, representing a single embedding.
+        num_neighbors (int): Required. The number of neighbors to return.
+        filter (List[Namespace]): Required. A list of Namespaces for filtering
+            the matching results. For example,
+            [Namespace("color", ["red"], []), Namespace("shape", [], ["square"])]
+            will match datapoints that satisfy "red color" but not include
+            datapoints with "square shape".
+        numeric_filter (List[NumericNamespace]): Required. A list of
+            NumericNamespaces for filtering the matching results. For example,
+            [NumericNamespace(name="cost", value_int=5, op="GREATER")] will limit
+            the matching results to datapoints with cost greater than 5.
+        per_crowding_attribute_neighbor_count (int): Required. The maximum
+            number of returned matches with the same crowding tag.
+
+    Returns:
+        List[List[aiplatform.matching_engine.matching_engine_index_endpoint.MatchNeighbor]] - A list of nearest neighbors for each query.
+    """
+    aiplatform.init(project=project, location=location)
+
+    _LOGGER.info(
+        f"Finding neighbors with filtering and crowding for index endpoint: {index_endpoint_name}, "
+        f"deployed index ID: {deployed_index_id}, num_neighbors: {num_neighbors}, "
+        f"per_crowding_attribute_neighbor_count: {per_crowding_attribute_neighbor_count}"
+    )
+    _LOGGER.info(f"  Filters: {filter}")
+    _LOGGER.info(f"  Numeric Filters: {numeric_filter}")
+
+    index_endpoint = aiplatform.MatchingEngineIndexEndpoint(
+        index_endpoint_name=index_endpoint_name
+    )
+
+    response = index_endpoint.find_neighbors(
+        deployed_index_id=deployed_index_id,
+        queries=queries,
+        num_neighbors=num_neighbors,
+        filter=filter,
+        numeric_filter=numeric_filter,
+        per_crowding_attribute_neighbor_count=per_crowding_attribute_neighbor_count,
+    )
+
+    _LOGGER.info("Filtering and crowding query results:")
+    for i, query_results in enumerate(response):
+        _LOGGER.info(f"  Query {i+1} results:")
+        for neighbor in query_results:
+            _LOGGER.info(f"    ID: {neighbor.id}, Distance: {neighbor.distance}")
+
+    return response
+# [END aiplatform_sdk_vector_search_find_neighbors_filtering_crowding_sample]
+
 
 if __name__ == "__main__":
     parser = argparse.ArgumentParser(
@@ -71,9 +179,46 @@
     )
     args = parser.parse_args()
 
-    _LOGGER.info("--- Running vector_search_find_neighbors_sample ---")
-    vector_search_find_neighbors_sample(
+    # Example usage for vector_search_find_neighbors_hybrid_queries
+    _LOGGER.info("\n--- Running vector_search_find_neighbors_hybrid_queries ---")
+    vector_search_find_neighbors_hybrid_queries(
         project=args.project,
         location=args.location,
         index_endpoint_name=args.index_endpoint_name,
         deployed_index_id=args.deployed_index_id,
-        queries=[[0.1, 0.2, 0.3, 0.4, 0.5]],  # Example query
         num_neighbors=args.num_neighbors,
     )
+
+    # Example usage for vector_search_find_neighbors_filtering_crowding
+    _LOGGER.info("\n--- Running vector_search_find_neighbors_filtering_crowding ---")
+
+    # Define example queries for filtering and crowding.
+    # Adjust dimensionality to match your index.
+    example_queries_fc = [
+        [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0],
+        [0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5],
+    ]
+
+    # Define example filters.
+    # These assume your index has attributes 'color', 'shape', and 'cost'.
+    # Adjust attribute names and values to match your index configuration.
+    example_filters = [
+        Namespace(name="color", allow_tokens=["red", "blue"], deny_tokens=[]),
+        Namespace(name="shape", allow_tokens=[], deny_tokens=["square"]),
+    ]
+    example_numeric_filters = [
+        NumericNamespace(name="cost", value_int=5, op="GREATER_EQUAL"),
+        NumericNamespace(name="rating", value_float=4.0, op="GREATER"),
+    ]
+    example_per_crowding_attribute_neighbor_count = 2 # Example value
+
+    vector_search_find_neighbors_filtering_crowding(
+        project=args.project,
+        location=args.location,
+        index_endpoint_name=args.index_endpoint_name,
+        deployed_index_id=args.deployed_index_id,
+        queries=example_queries_fc,
+        num_neighbors=args.num_neighbors,
+        filter=example_filters,
+        numeric_filter=example_numeric_filters,
+        per_crowding_attribute_neighbor_count=example_per_crowding_attribute_neighbor_count,
+    )