diff --git a/docs/_newsfragments/9999.breaking b/docs/_newsfragments/9999.breaking
new file mode 100644
--- /dev/null
+++ b/docs/_newsfragments/9999.breaking
@@ -0,0 +1,7 @@
+Error handlers are now selected based on the most specific exception type
+in the exception's Method Resolution Order (MRO), rather than LIFO order
+of registration. This means a handler for a base exception (e.g., `Exception`)
+will no longer override a more specific default handler (e.g., for `HTTPError`)
+if a derived exception is raised. Registration order now only matters when
+multiple handlers are registered for the *exact same* exception type, in
+which case the last one registered takes precedence.
diff --git a/docs/api/app.rst b/docs/api/app.rst
--- a/docs/api/app.rst
+++ b/docs/api/app.rst
@@ -107,3 +107,15 @@
       are the request and response objects, respectively, and
       ``params`` is a dict of URI template field names and their
       values.
+
+   .. versionchanged:: 1.x
+      Error handlers are now selected based on the most specific exception type
+      in the exception's Method Resolution Order (MRO), rather than LIFO order
+      of registration. This means a handler for a base exception (e.g.,
+      :py:class:`Exception`) will not override a more specific default handler
+      (e.g., for :py:class:`falcon.HTTPError`) if a derived exception is raised.
+      Registration order now only matters when multiple handlers are registered
+      for the *exact same* exception type, in which case the last one registered
+      takes precedence.
+
+
diff --git a/docs/user/errors.rst b/docs/user/errors.rst
--- a/docs/user/errors.rst
+++ b/docs/user/errors.rst
@@ -20,10 +20,60 @@
     app = falcon.App()
     app.add_error_handler(CustomError, handle_custom_error)
 
-When an exception is raised, Falcon iterates through the registered
-handlers in reverse order of registration (LIFO). The first handler
-that matches the exception type (using ``isinstance``) is invoked.
+.. versionchanged:: 1.x
+   Starting with Falcon 1.x, error handlers are selected based on the
+   most specific exception type in the exception's Method Resolution
+   Order (MRO), rather than LIFO order of registration.
+
+When an exception is raised, Falcon searches for a registered handler
+by iterating through the exception's Method Resolution Order (MRO),
+from the most specific type to the most general. The first handler
+found for any type in the MRO is invoked. This means a handler registered
+for a base exception (e.g., :py:class:`Exception`) will not override a
+more specific handler (either custom or default, e.g., for
+:py:class:`falcon.HTTPError`) if a derived exception is raised.
+
+Registration order now only matters when multiple handlers are registered
+for the *exact same* exception type, in which case the last one registered
+takes precedence.
+
+For example, consider the following custom exception hierarchy:
+
+.. code:: python
+
+    class MyBaseError(Exception):
+        pass
+
+    class MySpecificError(MyBaseError):
+        pass
+
+And these handlers:
+
+.. code:: python
+
+    def handle_base_error(ex, req, resp, params):
+        resp.status = falcon.HTTP_500
+        resp.media = {'message': 'Handled by MyBaseError'}
+
+    def handle_specific_error(ex, req, resp, params):
+        resp.status = falcon.HTTP_400
+        resp.media = {'message': 'Handled by MySpecificError'}
+
+If you register them like this:
+
+.. code:: python
+
+    app = falcon.App()
+    app.add_error_handler(MyBaseError, handle_base_error)
+    app.add_error_handler(MySpecificError, handle_specific_error)
+
+And then raise ``MySpecificError``, ``handle_specific_error`` will be
+invoked because ``MySpecificError`` is more specific than ``MyBaseError``
+in the exception's MRO.
+
+If you only registered ``handle_base_error`` and then raised
+``MySpecificError``, ``handle_base_error`` would be invoked as it's
+the most specific handler available in the MRO.
+
+Falcon automatically registers default handlers for :py:class:`falcon.HTTPError`
+and :py:class:`Exception`. These default handlers participate in the MRO-based
+selection process and can be overridden by registering your own handlers for
+those specific types.
 
 .. _error_serializers:
 
diff --git a/falcon/app.py b/falcon/app.py
--- a/falcon/app.py
+++ b/falcon/app.py
@@ -147,7 +147,16 @@
                  # NOTE(kgriffs): Default to JSON for now
                  media_type=None
                  ):
-        self._error_handlers = []
+        # NOTE(kgriffs): Change _error_handlers from a list to a dict
+        # to enable O(1) lookup and specificity-based selection.
+        self._error_handlers = {}
+
+        # NOTE(kgriffs): Register Falcon's default error handlers.
+        # These can be overridden by user-defined handlers via add_error_handler.
+        # The _handle_http_error and _handle_internal_error methods will be
+        # used as the default handlers for HTTPError and generic Exception, respectively.
+        # Ensure these methods conform to the handler signature (ex, req, resp, method_name).
+        self.add_error_handler(HTTPError, self._handle_http_error)
+        self.add_error_handler(Exception, self._handle_internal_error)
 
         self._router = router or routing.DefaultRouter()
         self._sinks = []
@@ -176,7 +185,27 @@
                 are the request and response objects, respectively, and
                 ``params`` is a dict of URI template field names and their
                 values.
-        """
-        self._error_handlers.insert(0, (exception, handler))
+
+        Note:
+            Starting with Falcon 1.x, error handlers are selected based on the
+            most specific exception type in the exception's Method Resolution
+            Order (MRO). This means a handler registered for a base exception
+            (e.g., ``Exception``) will not override a more specific handler
+            (either custom or default, e.g., for ``HTTPError``) if a derived
+            exception is raised. Registration order now only matters when
+            multiple handlers are registered for the *exact same* exception type,
+            in which case the last one registered takes precedence.
+        """
+        # NOTE(kgriffs): Store handlers in a dict for O(1) lookup
+        # and to allow specific overriding.
+        self._error_handlers[exception] = handler
+
+    def _find_error_handler(self, ex):
+        """Finds the most specific error handler for a given exception."""
+        exception_type = type(ex)
+
+        for cls in exception_type.__mro__:
+            if cls in self._error_handlers:
+                return self._error_handlers[cls]
+        return None
 
     def add_route(self, uri_template, resource):
         """Associates a URI path with a resource.
@@ -282,20 +311,24 @@
         self._sinks.insert(0, (prefix, handler))
 
     def _handle_exception(self, req, resp, ex, method_name):
-        # NOTE(kgriffs): Try to find a custom error handler first.
-        for handler_type, handler in self._error_handlers:
-            if isinstance(ex, handler_type):
-                handler(ex, req, resp, method_name)
-                return
-
-        # NOTE(kgriffs): If no custom handler, check for HTTPError.
-        if isinstance(ex, HTTPError):
-            self._handle_http_error(ex, req, resp, method_name)
-            return
-
-        # NOTE(kgriffs): Fall back to generic internal error handler.
-        self._handle_internal_error(ex, req, resp, method_name)
+        # NOTE(kgriffs): Find the most specific handler, which could be
+        # a custom one or one of Falcon's defaults (HTTPError or generic Exception).
+        handler = self._find_error_handler(ex)
+
+        # A handler should always be found because Falcon registers
+        # a default handler for Exception during App initialization.
+        if handler is None:
+            # NOTE(kgriffs): This indicates an internal framework error.
+            # Re-raise to make the bug apparent.
+            raise RuntimeError(
+                'No error handler found for exception: ' + str(type(ex)) +
+                '. This indicates an internal framework error in Falcon.'
+            )
+
+        handler(ex, req, resp, method_name)
+
+    # NOTE(kgriffs): Ensure _handle_http_error and _handle_internal_error
+    # methods have the signature (ex, req, resp, method_name) to be
+    # compatible with the new handler dispatch mechanism.
+    # If they currently don't, they will need to be adjusted.
 
     def _handle_http_error(self, ex, req, resp, method_name):
         # NOTE(kgriffs): HTTPError is a special case, since it is used to
diff --git a/tests/test_app.py b/tests/test_app.py
--- a/tests/test_app.py
+++ b/tests/test_app.py
@@ -1,6 +1,7 @@
 import pytest
 
 import falcon
+from falcon import HTTPError, HTTPForbidden, HTTPNotFound
 from falcon.testing import TestClient
 
 
@@ -107,3 +108,143 @@
         assert result.status == falcon.HTTP_404
         assert 'title' in result.json
         assert result.json['title'] == 'Not Found'
+
+
+# Define custom exceptions for testing inheritance
+class CustomBaseError(Exception):
+    pass
+
+
+class CustomHTTPError(HTTPError):
+    pass
+
+
+class SpecificCustomHTTPError(CustomHTTPError):
+    pass
+
+
+class AnotherCustomError(CustomBaseError):
+    pass
+
+
+# Mock handler functions
+def mock_exception_handler(ex, req, resp, params):
+    resp.status = falcon.HTTP_500
+    resp.media = {'message': 'Handled by Exception'}
+
+
+def mock_http_error_handler(ex, req, resp, params):
+    resp.status = falcon.HTTP_400
+    resp.media = {'message': 'Handled by HTTPError'}
+
+
+def mock_custom_http_error_handler(ex, req, resp, params):
+    resp.status = falcon.HTTP_401
+    resp.media = {'message': 'Handled by CustomHTTPError'}
+
+
+def mock_specific_custom_http_error_handler(ex, req, resp, params):
+    resp.status = falcon.HTTP_402
+    resp.media = {'message': 'Handled by SpecificCustomHTTPError'}
+
+
+def mock_custom_base_error_handler(ex, req, resp, params):
+    resp.status = falcon.HTTP_501
+    resp.media = {'message': 'Handled by CustomBaseError'}
+
+
+def mock_another_custom_error_handler(ex, req, resp, params):
+    resp.status = falcon.HTTP_502
+    resp.media = {'message': 'Handled by AnotherCustomError'}
+
+
+class TestAppErrorHandlingSpecificity:
+
+    @pytest.fixture
+    def client(self):
+        app = falcon.App()
+        # NOTE(kgriffs): Default handlers for HTTPError and Exception are
+        # automatically registered in App.__init__ now.
+        return TestClient(app)
+
+    def test_default_http_error_handler_precedence(self, client):
+        # Register a general Exception handler
+        client.app.add_error_handler(Exception, mock_exception_handler)
+
+        # Raise a specific HTTPError (e.g., HTTPForbidden)
+        class MyResource:
+            def on_get(self, req, resp):
+                raise HTTPForbidden()
+
+        client.app.add_route('/test', MyResource())
+        result = client.simulate_get('/test')
+
+        # Expect Falcon's default HTTPError handler, not the custom Exception handler
+        # The default HTTPError handler sets status based on the HTTPError instance
+        assert result.status == falcon.HTTP_403  # HTTPForbidden default status
+        assert 'title' in result.json  # Default HTTPError response structure
+
+    def test_custom_handler_for_specific_type(self, client):
+        client.app.add_error_handler(SpecificCustomHTTPError, mock_specific_custom_http_error_handler)
+        client.app.add_error_handler(CustomHTTPError, mock_custom_http_error_handler)
+        client.app.add_error_handler(HTTPError, mock_http_error_handler)
+        client.app.add_error_handler(Exception, mock_exception_handler)
+
+        class MyResource:
+            def on_get(self, req, resp):
+                raise SpecificCustomHTTPError()
+
+        client.app.add_route('/test', MyResource())
+        result = client.simulate_get('/test')
+
+        assert result.status == falcon.HTTP_402
+        assert result.json == {'message': 'Handled by SpecificCustomHTTPError'}
+
+    def test_custom_handler_for_intermediate_type(self, client):
+        client.app.add_error_handler(CustomHTTPError, mock_custom_http_error_handler)
+        client.app.add_error_handler(HTTPError, mock_http_error_handler)
+        client.app.add_error_handler(Exception, mock_exception_handler)
+
+        class MyResource:
+            def on_get(self, req, resp):
+                raise SpecificCustomHTTPError()  # No handler for this exact type
+
+        client.app.add_route('/test', MyResource())
+        result = client.simulate_get('/test')
+
+        assert result.status == falcon.HTTP_401
+        assert result.json == {'message': 'Handled by CustomHTTPError'}
+
+    def test_custom_handler_for_base_type(self, client):
+        client.app.add_error_handler(HTTPError, mock_http_error_handler)
+        client.app.add_error_handler(Exception, mock_exception_handler)
+
+        class MyResource:
+            def on_get(self, req, resp):
+                raise SpecificCustomHTTPError()  # No handler for this or CustomHTTPError
+
+        client.app.add_route('/test', MyResource())
+        result = client.simulate_get('/test')
+
+        assert result.status == falcon.HTTP_400
+        assert result.json == {'message': 'Handled by HTTPError'}
+
+    def test_custom_handler_for_general_exception(self, client):
+        client.app.add_error_handler(Exception, mock_exception_handler)
+
+        class MyResource:
+            def on_get(self, req, resp):
+                raise ValueError('Something went wrong')  # Not an HTTPError
+
+        client.app.add_route('/test', MyResource())
+        result = client.simulate_get('/test')
+
+        assert result.status == falcon.HTTP_500
+        assert result.json == {'message': 'Handled by Exception'}
+
+    def test_registration_order_for_same_type(self, client):
+        # Register handler1, then handler2 for the same type
+        client.app.add_error_handler(CustomBaseError, mock_custom_base_error_handler)
+        client.app.add_error_handler(CustomBaseError, mock_another_custom_error_handler)  # This should override
+
+        class MyResource:
+            def on_get(self, req, resp):
+                raise CustomBaseError()
+
+        client.app.add_route('/test', MyResource())
+        result = client.simulate_get('/test')
+
+        # Expect the last registered handler for CustomBaseError
+        assert result.status == falcon.HTTP_502
+        assert result.json == {'message': 'Handled by AnotherCustomError'}
+
+    def test_no_custom_handler_falls_back_to_default_http_error(self, client):
+        # No custom handlers registered for HTTPError or its subclasses
+        class MyResource:
+            def on_get(self, req, resp):
+                raise HTTPNotFound()
+
+        client.app.add_route('/test', MyResource())
+        result = client.simulate_get('/test')
+
+        # Expect Falcon's default HTTPNotFound handler
+        assert result.status == falcon.HTTP_404
+        assert 'title' in result.json
+
+    def test_no_custom_handler_falls_back_to_default_exception(self, client):
+        # No custom handlers registered for any specific exception
+        class MyResource:
+            def on_get(self, req, resp):
+                raise RuntimeError('Generic error')
+
+        client.app.add_route('/test', MyResource())
+        result = client.simulate_get('/test')
+
+        # Expect Falcon's default Exception handler (internal error)
+        assert result.status == falcon.HTTP_500
+        assert 'title' in result.json  # Default internal error response structure
