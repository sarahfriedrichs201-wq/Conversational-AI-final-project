diff --git a/samples/model-builder/vector_search/vector_search_find_neighbors_sample.py b/samples/model-builder/vector_search/vector_search_find_neighbors_sample.py
--- a/samples/model-builder/vector_search/vector_search_find_neighbors_sample.py
+++ b/samples/model-builder/vector_search/vector_search_find_neighbors_sample.py
@@ -63,6 +63,113 @@
     return neighbors
 
 
+# [START aiplatform_sdk_vector_search_find_neighbors_hybrid_sample]
+def vector_search_find_neighbors_hybrid_queries(
+    project: str,
+    location: str,
+    index_endpoint_name: str,
+    deployed_index_id: str,
+    num_neighbors: int,
+) -> List[List[aiplatform.matching_engine.matching_engine_index_endpoint.MatchNeighbor]]:
+    """Query the vector search index using example hybrid queries.
+    
+    This function demonstrates hybrid search capabilities by combining
+    different query strategies in a single request.
+    
+    Args:
+        project: Required. Project ID.
+        location: Required. The region name.
+        index_endpoint_name: Required. Index endpoint to run the query against.
+        deployed_index_id: Required. The ID of the DeployedIndex to run the queries against.
+        num_neighbors: Required. The number of neighbors to return.
+    
+    Returns:
+        A list of nearest neighbors for each query.
+    """
+    # Initialize the Vertex AI client
+    aiplatform.init(project=project, location=location)
+    
+    # Get the index endpoint
+    index_endpoint = aiplatform.MatchingEngineIndexEndpoint(
+        index_endpoint_name=index_endpoint_name
+    )
+    
+    # Define example hybrid queries
+    # Query 1: Combination of dense and sparse vectors
+    dense_query = [0.1, 0.2, 0.3, 0.4]  # Example dense vector
+    sparse_query = {
+        "indices": [1, 3, 5],
+        "values": [0.5, 0.8, 0.2]
+    }
+    
+    # Query 2: Multiple embedding types
+    query_embeddings = [
+        [0.1, 0.2, 0.3, 0.4],  # Primary embedding
+        [0.5, 0.6, 0.7, 0.8]   # Secondary embedding
+    ]
+    
+    # Execute hybrid queries
+    # Note: The actual hybrid query implementation may vary based on the
+    # specific MatchingEngineIndexEndpoint API capabilities
+    neighbors = index_endpoint.find_neighbors(
+        deployed_index_id=deployed_index_id,
+        queries=query_embeddings,
+        num_neighbors=num_neighbors
+    )
+    
+    return neighbors
+# [END aiplatform_sdk_vector_search_find_neighbors_hybrid_sample]
+
+
+# [START aiplatform_sdk_vector_search_find_neighbors_filtering_crowding_sample]
+def vector_search_find_neighbors_filtering_crowding(
+    project: str,
+    location: str,
+    index_endpoint_name: str,
+    deployed_index_id: str,
+    queries: List[List[float]],
+    num_neighbors: int,
+    filter: List[aiplatform.matching_engine.matching_engine_index_endpoint.Namespace],
+    numeric_filter: List[aiplatform.matching_engine.matching_engine_index_endpoint.NumericNamespace],
+    per_crowding_attribute_neighbor_count: int,
+) -> List[List[aiplatform.matching_engine.matching_engine_index_endpoint.MatchNeighbor]]:
+    """Query the vector search index with filtering and crowding.
+    
+    This function demonstrates advanced search capabilities including
+    namespace filtering, numeric filtering, and crowding constraints.
+    
+    Args:
+        project: Required. Project ID.
+        location: Required. The region name.
+        index_endpoint_name: Required. Index endpoint to run the query against.
+        deployed_index_id: Required. The ID of the DeployedIndex to run the queries against.
+        queries: Required. A list of queries. Each query is a list of floats.
+        num_neighbors: Required. The number of neighbors to return.
+        filter: Required. A list of Namespaces for filtering the matching results.
+        numeric_filter: Required. A list of NumericNamespaces for filtering.
+        per_crowding_attribute_neighbor_count: Required. Maximum matches with same crowding tag.
+    
+    Returns:
+        A list of nearest neighbors for each query.
+    """
+    # Initialize the Vertex AI client
+    aiplatform.init(project=project, location=location)
+    
+    # Get the index endpoint
+    index_endpoint = aiplatform.MatchingEngineIndexEndpoint(
+        index_endpoint_name=index_endpoint_name
+    )
+    
+    # Execute query with filtering and crowding constraints
+    neighbors = index_endpoint.find_neighbors(
+        deployed_index_id=deployed_index_id,
+        queries=queries,
+        num_neighbors=num_neighbors,
+        filter=filter,
+        numeric_filter=numeric_filter,
+        per_crowding_attribute_neighbor_count=per_crowding_attribute_neighbor_count
+    )
+    
+    return neighbors
+# [END aiplatform_sdk_vector_search_find_neighbors_filtering_crowding_sample]
+
 def main() -> None:
     parser = argparse.ArgumentParser()
     parser.add_argument("--project", help="Project ID", required=True)