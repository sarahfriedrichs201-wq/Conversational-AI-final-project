The following document outlines the implementation plan for the `discretize` function within the `pgmpy` library. This function will provide a utility for converting continuous data in a pandas DataFrame into discrete categories, using either equal-width or equal-frequency binning methods.

## Repository Overview

`pgmpy` is a Python package for working with Probabilistic Graphical Models, including Bayesian Networks. The `pgmpy/utils` directory typically houses helper functions that are generally useful across different modules but don't belong to a specific model or algorithm. The `discretize` function fits well within this utility module, providing a foundational data preprocessing step often required before applying many PGM algorithms.

The project uses `pandas` for data manipulation, `numpy` for numerical operations, and adheres to a clear coding style, including comprehensive docstrings and type hints. Testing is done using `pytest`.

## Feature Description

The `discretize` function will take a pandas DataFrame containing continuous numerical data and convert specified columns into discrete categories. Users can define the number of bins (cardinality) for each variable and optionally provide custom labels for these bins. Two discretization methods will be supported: "rounding" (equal-width bins) and "quantile" (equal-frequency bins).

**Function Signature:**
`pgmpy/utils/utils.py`
```python
def discretize(data, cardinality, labels=dict(), method="rounding"):
```

## Implementation Plan

The implementation will involve adding the `discretize` function to `pgmpy/utils/utils.py`, ensuring robust input validation, implementing the core discretization logic using pandas functions, and providing comprehensive tests and documentation.

### Step 1: Setup and Dependencies

1.  **Create a new branch:** Start by creating a new feature branch from `dev` (e.g., `feature/discretize-function`).
2.  **Verify dependencies:** Ensure `pandas` and `numpy` are installed and up-to-date, as they are core to this functionality. These should already be covered by `requirements/runtime.txt`.

### Step 2: Add `discretize` function to `pgmpy/utils/utils.py`

Create the function signature and an initial docstring.

```python
# pgmpy/utils/utils.py

import pandas as pd
import numpy as np

def discretize(data, cardinality, labels=None, method="rounding"):
    """
    Discretizes a given continuous dataset.

    Parameters
    ----------
    data: pandas.DataFrame
        The dataset to discretize. All columns specified in `cardinality` must have continuous values.

    cardinality: dict
        A dictionary of the form (str: int) representing the number of bins
        to create for each of the variables. Keys must correspond to column names in `data`.

    labels: dict (default: None)
        A dictionary of the form (str: list) representing the label names for
        each variable in the discretized dataframe. If provided for a column,
        the length of the list must match the `cardinality` for that column.
        If None or an empty dict, default labels will be generated by pandas.

    method: str (default: "rounding")
        The discretization method to use.
        - "rounding": Equal width bins are created using `pandas.cut`.
        - "quantile": Bins are created such that each bin has an approximately equal number of datapoints,
                      using `pandas.qcut`.

    Examples
    --------
    >>> import numpy as np
    >>> import pandas as pd
    >>> from pgmpy.utils import discretize
    >>> rng = np.random.default_rng(42)
    >>> X = rng.standard_normal(1000)
    >>> Y = 0.2 * X + rng.standard_normal(1000)
    >>> Z = 0.4 * X + 0.5 * Y + rng.standard_normal(1000)
    >>> df = pd.DataFrame({"X": X, "Y": Y, "Z": Z})
    >>> df_disc = discretize(df, cardinality={'X': 3, 'Y': 3, 'Z': 3}, labels={'X': ['low', 'mid', 'high'], 'Y': ['low', 'mid', 'high'], 'Z': ['low', 'mid', 'high']})
    >>> df_disc.head()
        X    Y    Z
    0   mid  mid  mid
    1   mid  mid  low
    2   mid  mid  mid
    3  high  mid  mid
    4   low  mid  low

    Returns
    -------
    pandas.DataFrame: A discretized dataframe.
    """
    # Implementation details will go here
    pass
```
*Note: The problem description's function signature has `labels=dict()`. However, `dict()` as a default mutable argument can lead to unexpected behavior. It's generally safer to use `labels=None` and then initialize an empty dict if `None` is passed, or handle it as `dict()` if that's the explicit design choice. For this plan, I'll use `labels=None` and handle it, as it's a common Python best practice. If `labels=dict()` is strictly required, ensure it's handled carefully (e.g., `labels = labels if labels is not None else {}`). Given the problem description's `default: None` in the parameter description, `labels=None` seems more aligned with the intent.*

### Step 3: Input Validation

Implement robust checks for all input parameters.

```python
    # Input Validation
    if not isinstance(data, pd.DataFrame):
        raise TypeError("Input 'data' must be a pandas.DataFrame.")
    if data.empty:
        return data.copy() # Return empty DataFrame if input is empty

    if not isinstance(cardinality, dict):
        raise TypeError("Input 'cardinality' must be a dictionary.")
    if not cardinality:
        raise ValueError("Input 'cardinality' cannot be empty.")

    if labels is not None and not isinstance(labels, dict):
        raise TypeError("Input 'labels' must be a dictionary or None.")

    if method not in ["rounding", "quantile"]:
        raise ValueError(f"Invalid method '{method}'. Must be 'rounding' or 'quantile'.")

    # Ensure all columns in cardinality exist in data and are numeric
    for col, num_bins in cardinality.items():
        if col not in data.columns:
            raise ValueError(f"Column '{col}' specified in 'cardinality' not found in 'data'.")
        if not pd.api.types.is_numeric_dtype(data[col]):
            raise TypeError(f"Column '{col}' must be numeric for discretization. Found type: {data[col].dtype}")
        if not isinstance(num_bins, int) or num_bins <= 1:
            raise ValueError(f"Cardinality for column '{col}' must be an integer greater than 1. Got {num_bins}.")

    # Validate labels if provided
    if labels:
        for col, col_labels in labels.items():
            if col not in cardinality:
                # Optionally warn or ignore labels for columns not being discretized
                # For now, let's raise an error for strictness.
                raise ValueError(f"Labels provided for column '{col}' which is not in 'cardinality'.")
            if not isinstance(col_labels, list):
                raise TypeError(f"Labels for column '{col}' must be a list. Got {type(col_labels)}.")
            if len(col_labels) != cardinality[col]:
                raise ValueError(f"Length of labels for column '{col}' ({len(col_labels)}) must match cardinality ({cardinality[col]}).")
```

### Step 4: Core Discretization Logic

Iterate through the columns specified in `cardinality` and apply either `pd.cut` or `pd.qcut`.

```python
    discretized_df = data.copy() # Work on a copy to avoid modifying the original DataFrame

    for col, num_bins in cardinality.items():
        col_labels = labels.get(col) if labels else None

        if method == "rounding":
            # pd.cut for equal-width bins
            # include_lowest=True ensures the minimum value is included in the first bin.
            # If there are too few unique values for the requested bins, pd.cut might raise an error.
            # However, for 'rounding', it usually handles it by creating fewer bins if necessary.
            try:
                discretized_df[col] = pd.cut(data[col], bins=num_bins, labels=col_labels, include_lowest=True)
            except Exception as e:
                raise ValueError(f"Error discretizing column '{col}' using 'rounding' method: {e}")

        elif method == "quantile":
            # pd.qcut for equal-frequency bins
            # duplicates='drop' handles cases where there aren't enough unique values
            # to create distinct quantiles, preventing an error by dropping non-unique bin edges.
            try:
                discretized_df[col] = pd.qcut(data[col], q=num_bins, labels=col_labels, duplicates='drop')
            except Exception as e:
                # Specific error for qcut if duplicates='raise' was used or other issues
                raise ValueError(f"Error discretizing column '{col}' using 'quantile' method. "
                                 f"This might happen if there are too few unique values for the requested number of quantiles. "
                                 f"Original error: {e}")
    return discretized_df
```

### Step 5: Update `pgmpy/utils/__init__.py`

To make `discretize` directly importable from `pgmpy.utils`, add it to the `__init__.py` file.

```python
# pgmpy/utils/__init__.py

from pgmpy.utils.utils import (
    # ... other utilities
    discretize,
)
```

### Step 6: Testing

Create a new test file `pgmpy/tests/test_utils/test_utils.py` or add to an existing one if appropriate. Follow the existing testing style using `pytest`.

```python
# pgmpy/tests/test_utils/test_utils.py

import pytest
import pandas as pd
import numpy as np
from pgmpy.utils import discretize

class TestDiscretize:
    def setup_method(self):
        self.rng = np.random.default_rng(42)
        self.X = self.rng.standard_normal(1000)
        self.Y = 0.2 * self.X + self.rng.standard_normal(1000)
        self.Z = 0.4 * self.X + 0.5 * self.Y + self.rng.standard_normal(1000)
        self.df = pd.DataFrame({"X": self.X, "Y": self.Y, "Z": self.Z, "A": [1, 2, 3] * 333 + [1]})

    def test_basic_rounding(self):
        cardinality = {'X': 3, 'Y': 3}
        df_disc = discretize(self.df, cardinality=cardinality, method="rounding")

        assert isinstance(df_disc, pd.DataFrame)
        assert df_disc.shape == self.df.shape
        assert set(df_disc.columns) == set(self.df.columns)

        # Check if specified columns are categorical
        assert pd.api.types.is_categorical_dtype(df_disc['X'])
        assert pd.api.types.is_categorical_dtype(df_disc['Y'])
        # Check if non-specified columns are unchanged
        assert pd.api.types.is_numeric_dtype(df_disc['Z'])
        assert pd.api.types.is_numeric_dtype(df_disc['A'])

        # Check number of categories
        assert len(df_disc['X'].cat.categories) == 3
        assert len(df_disc['Y'].cat.categories) == 3

        # Check specific values (using the example from problem description)
        expected_head = pd.DataFrame({
            'X': pd.Categorical(['mid', 'mid', 'mid', 'high', 'low'], categories=['low', 'mid', 'high']),
            'Y': pd.Categorical(['mid', 'mid', 'mid', 'mid', 'mid'], categories=['low', 'mid', 'high']),
            'Z': self.df['Z'].head(), # Z should be unchanged
            'A': self.df['A'].head() # A should be unchanged
        })
        # Re-run the example to get exact categories for comparison
        df_example = pd.DataFrame({"X": self.X, "Y": self.Y, "Z": self.Z})
        df_disc_example = discretize(df_example, cardinality={'X': 3, 'Y': 3, 'Z': 3}, labels={'X': ['low', 'mid', 'high'], 'Y': ['low', 'mid', 'high'], 'Z': ['low', 'mid', 'high']})
        pd.testing.assert_frame_equal(df_disc_example.head(), expected_head.drop(columns=['A']))


    def test_basic_quantile(self):
        cardinality = {'X': 4}
        df_disc = discretize(self.df, cardinality=cardinality, method="quantile")

        assert pd.api.types.is_categorical_dtype(df_disc['X'])
        assert len(df_disc['X'].cat.categories) == 4

    def test_with_labels(self):
        cardinality = {'X': 2}
        labels = {'X': ['group1', 'group2']}
        df_disc = discretize(self.df, cardinality=cardinality, labels=labels)

        assert list(df_disc['X'].cat.categories) == ['group1', 'group2']

    def test_original_dataframe_unchanged(self):
        original_df_copy = self.df.copy()
        discretize(self.df, cardinality={'X': 3})
        pd.testing.assert_frame_equal(self.df, original_df_copy)

    # --- Error Handling Tests ---
    def test_invalid_data_type(self):
        with pytest.raises(TypeError, match="Input 'data' must be a pandas.DataFrame."):
            discretize(np.array([1, 2, 3]), cardinality={'X': 2})

    def test_empty_cardinality(self):
        with pytest.raises(ValueError, match="Input 'cardinality' cannot be empty."):
            discretize(self.df, cardinality={})

    def test_invalid_method(self):
        with pytest.raises(ValueError, match="Invalid method 'invalid'. Must be 'rounding' or 'quantile'."):
            discretize(self.df, cardinality={'X': 2}, method="invalid")

    def test_column_not_in_data(self):
        with pytest.raises(ValueError, match="Column 'NonExistent' specified in 'cardinality' not found in 'data'."):
            discretize(self.df, cardinality={'NonExistent': 2})

    def test_non_numeric_column(self):
        df_mixed = self.df.copy()
        df_mixed['str_col'] = ['a'] * len(df_mixed)
        with pytest.raises(TypeError, match="Column 'str_col' must be numeric for discretization."):
            discretize(df_mixed, cardinality={'str_col': 2})

    def test_invalid_cardinality_value(self):
        with pytest.raises(ValueError, match="Cardinality for column 'X' must be an integer greater than 1. Got 1."):
            discretize(self.df, cardinality={'X': 1})
        with pytest.raises(ValueError, match="Cardinality for column 'X' must be an integer greater than 1. Got 0."):
            discretize(self.df, cardinality={'X': 0})
        with pytest.raises(ValueError, match="Cardinality for column 'X' must be an integer greater than 1. Got 2.5."):
            discretize(self.df, cardinality={'X': 2.5})

    def test_labels_wrong_length(self):
        cardinality = {'X': 3}
        labels = {'X': ['low', 'high']} # Incorrect length
        with pytest.raises(ValueError, match="Length of labels for column 'X' \\(2\\) must match cardinality \\(3\\)."):
            discretize(self.df, cardinality=cardinality, labels=labels)

    def test_labels_for_non_discretized_column(self):
        cardinality = {'X': 2}
        labels = {'Y': ['a', 'b']} # Y not in cardinality
        with pytest.raises(ValueError, match="Labels provided for column 'Y' which is not in 'cardinality'."):
            discretize(self.df, cardinality=cardinality, labels=labels)

    def test_qcut_with_few_unique_values(self):
        df_few_unique = pd.DataFrame({'A': [1, 1, 1, 2, 2, 3, 3, 3]})
        cardinality = {'A': 4} # More bins than unique values
        df_disc = discretize(df_few_unique, cardinality=cardinality, method="quantile")
        # With duplicates='drop', it should still work, but might result in fewer categories
        assert pd.api.types.is_categorical_dtype(df_disc['A'])
        assert len(df_disc['A'].cat.categories) <= 4 # Should be 3 categories (1,2,3)

    def test_empty_dataframe(self):
        empty_df = pd.DataFrame(columns=['X', 'Y'])
        cardinality = {'X': 2}
        df_disc = discretize(empty_df, cardinality=cardinality)
        pd.testing.assert_frame_equal(df_disc, empty_df)
        assert df_disc.empty
```

### Step 7: Documentation and Changelog

1.  **Docstring:** Ensure the docstring for `discretize` is complete, accurate, and follows the existing NumPy/Sphinx style used in `pgmpy`. The example provided in the problem description should be included.
2.  **`CHANGELOG.md`:** Add an entry under the `## [0.1.26]` section (or the next appropriate version) under `### Added` for `pgmpy.utils.discretize`. The problem description already includes this, so just ensure it's present and correctly formatted.
    ```markdown
    ## [0.1.26] - 2024-08-09
    ### Added
    ...
    3. Adds a simple discretization method: `pgmpy.utils.discretize`.
    ...
    ```
3.  **`AUTHORS.rst`:** If you are a new contributor, add your name and email to the `Contributors` section in `AUTHORS.rst`.

### Step 8: Code Style and Review

1.  **PEP 8:** Ensure the new code adheres to PEP 8 guidelines. Use a linter (like `flake8` or `black`) if available in the project's CI/CD setup or locally.
2.  **Type Hinting:** Add type hints to the function signature and relevant variables for improved readability and maintainability.
    ```python
    from typing import Dict, List, Optional, Union

    def discretize(data: pd.DataFrame, cardinality: Dict[str, int],
                   labels: Optional[Dict[str, List[str]]] = None,
                   method: str = "rounding") -> pd.DataFrame:
    ```
3.  **Clarity:** Ensure variable names are descriptive and the logic is easy to follow.
4.  **Error Messages:** Make sure error messages are informative and guide the user on how to fix the issue.

By following these steps, the `discretize` function will be robustly implemented, thoroughly tested, and well-documented, integrating seamlessly into the `pgmpy` codebase.