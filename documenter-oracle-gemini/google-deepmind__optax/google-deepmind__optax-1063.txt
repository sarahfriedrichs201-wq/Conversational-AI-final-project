This document outlines the implementation plan for adding `optax.tree_utils.tree_random_split` to the Optax library. This new public function will expose the functionality of the formerly private `_tree_rng_keys_split` function, providing a utility to split a JAX PRNGKey into a tree of keys matching a target structure.

## 1. Introduction

The goal is to expose the existing private function `_tree_rng_keys_split` from `optax/tree_utils/_random.py` as a public API function named `optax.tree_utils.tree_random_split`. This function is useful for generating random keys that mirror the structure of a given JAX PyTree, which is a common pattern in JAX-based machine learning models.

## 2. Repository Overview

Optax is a JAX-based library for gradient processing and optimization. Key characteristics relevant to this task include:

*   **JAX and Chex Integration**: Optax heavily relies on JAX for array manipulation and `chex` for utilities like `PRNGKey` (pseudo-random number generator key) and `ArrayTree` (arbitrary nested structures of JAX arrays).
*   **Modular Design**: The library emphasizes small, composable building blocks. New utilities should fit this philosophy.
*   **Code Style**: Optax prioritizes readability and clear structuring, often mirroring mathematical equations. Adherence to `black` and `isort` is expected.
*   **Testing**: All new features require comprehensive unit tests. Tests are run via `bash test.sh`.
*   **Documentation**: Documentation is built using Sphinx, `myst-nb`, and `sphinx-book-theme`, hosted on `readthedocs.io`. API documentation is typically generated using `autodoc` directives.

## 3. Implementation Plan

The implementation will involve modifying an existing file, adding an import to an `__init__.py` file, creating a new test, and updating documentation.

### Step 1: Locate and Rename the Private Function

The function `_tree_rng_keys_split` is located in `optax/tree_utils/_random.py`. We will rename this function to `tree_random_split` to make it public.

**File**: `optax/tree_utils/_random.py`

**Action**:
1.  Open `optax/tree_utils/_random.py`.
2.  Locate the definition of `_tree_rng_keys_split`.
3.  Rename the function to `tree_random_split`.

**Pseudo-code (before)**:
```python
# optax/tree_utils/_random.py

import jax
import jax.tree_util as jtu
import chex

def _tree_rng_keys_split(rng_key: chex.PRNGKey, target_tree: chex.ArrayTree) -> chex.ArrayTree:
  """Splits a single PRNGKey into a tree of keys matching `target_tree`'s structure.

  Args:
    rng_key: The PRNGKey to split.
    target_tree: The tree whose structure to match.

  Returns:
    A tree of PRNGKeys, with the same structure as `target_tree`.
  """
  num_leaves = jtu.tree_structure(target_tree).num_leaves
  if num_leaves == 0:
    return target_tree
  return jtu.tree_unflatten(
      jtu.tree_structure(target_tree), jax.random.split(rng_key, num_leaves))

# ... other functions
```

**Pseudo-code (after renaming)**:
```python
# optax/tree_utils/_random.py

import jax
import jax.tree_util as jtu
import chex

def tree_random_split(rng_key: chex.PRNGKey, target_tree: chex.ArrayTree) -> chex.ArrayTree:
  """Splits a single PRNGKey into a tree of keys matching `target_tree`'s structure.

  Args:
    rng_key: The PRNGKey to split.
    target_tree: The tree whose structure to match.

  Returns:
    A tree of PRNGKeys, with the same structure as `target_tree`.
  """
  num_leaves = jtu.tree_structure(target_tree).num_leaves
  if num_leaves == 0:
    return target_tree
  return jtu.tree_unflatten(
      jtu.tree_structure(target_tree), jax.random.split(rng_key, num_leaves))

# ... other functions
```

### Step 2: Update Docstring and Type Hints

Ensure the docstring is public-facing, clear, and matches the style of other Optax functions. The provided `tree_split_key_like` description in the problem statement serves as a good template. The current docstring is already quite good, but we can ensure it's fully aligned.

**File**: `optax/tree_utils/_random.py`

**Action**:
1.  Review the docstring for `tree_random_split`.
2.  Ensure it clearly explains the function's purpose, arguments, and return value.
3.  Confirm type hints (`chex.PRNGKey`, `chex.ArrayTree`) are correct.

The existing docstring is already suitable for a public function. No changes are strictly necessary here unless further clarity is desired.

### Step 3: Expose in Public API

To make `tree_random_split` accessible via `optax.tree_utils.tree_random_split`, it must be imported into the `optax/tree_utils/__init__.py` file.

**File**: `optax/tree_utils/__init__.py`

**Action**:
1.  Open `optax/tree_utils/__init__.py`.
2.  Add an import statement for `tree_random_split` from `optax.tree_utils._random`.

**Pseudo-code**:
```python
# optax/tree_utils/__init__.py

# Copyright 2019 DeepMind Technologies Limited. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ==============================================================================
"""Utilities for manipulating JAX pytrees."""

from optax.tree_utils._random import tree_random_split  # Add this line
from optax.tree_utils.tree_utils import (
    # ... existing imports ...
)
```

### Step 4: Add Unit Tests

A new unit test should be added to verify the functionality of `tree_random_split`. This test should cover basic usage and edge cases (e.g., empty trees).

**File**: `optax/tree_utils/_random_test.py` (create if it doesn't exist, otherwise add to it)

**Action**:
1.  Create `optax/tree_utils/_random_test.py` if it doesn't exist.
2.  Add a test class or function to test `optax.tree_utils.tree_random_split`.
3.  Verify that the output tree has the correct structure and contains `PRNGKey` instances.
4.  Test with different tree structures (e.g., flat, nested, empty).

**Pseudo-code for `optax/tree_utils/_random_test.py`**:
```python
# optax/tree_utils/_random_test.py

from absl.testing import absltest
from absl.testing import parameterized

import jax
import jax.numpy as jnp
import jax.tree_util as jtu
import chex

# Import the public function
from optax.tree_utils import tree_random_split

class TreeRandomSplitTest(chex.TestCase):

  @parameterized.parameters(
      (jnp.array(1.),),
      ({'a': jnp.array(1.), 'b': (jnp.array(2.), jnp.array(3.))},),
      ((),),  # Empty tuple
      ({},),  # Empty dict
      (None,), # None as a leaf
  )
  def test_tree_random_split(self, target_tree):
    rng_key = jax.random.PRNGKey(0)
    split_keys_tree = tree_random_split(rng_key, target_tree)

    # Assert that the structure matches
    chex.assert_trees_equal(jtu.tree_structure(target_tree), jtu.tree_structure(split_keys_tree))

    # Assert that all leaves are PRNGKeys
    jtu.tree_map(lambda k: self.assertIsInstance(k, chex.PRNGKey), split_keys_tree)

    # Assert that keys are distinct (for non-empty trees)
    if jtu.tree_structure(target_tree).num_leaves > 1:
      leaves = jtu.tree_leaves(split_keys_tree)
      # Convert keys to integers for comparison
      int_leaves = [k[0] for k in leaves]
      self.assertLen(set(int_leaves), len(int_leaves)) # All keys should be unique

    # Test that splitting the same key with the same tree yields different subkeys
    # but the same structure
    rng_key_2 = jax.random.PRNGKey(1)
    split_keys_tree_2 = tree_random_split(rng_key_2, target_tree)
    chex.assert_trees_equal(jtu.tree_structure(target_tree), jtu.tree_structure(split_keys_tree_2))
    if jtu.tree_structure(target_tree).num_leaves > 0:
      # The actual key values should be different if the initial key is different
      with self.assertRaises(AssertionError): # Expect assertion error if keys are identical
        chex.assert_trees_equal(split_keys_tree, split_keys_tree_2)


if __name__ == '__main__':
  absltest.main()
```

### Step 5: Update Documentation

The new public function should be documented in the Optax API reference. This typically involves adding an entry to the relevant Sphinx `.rst` file.

**File**: `docs/api/tree_utils.rst` (or similar, depending on Optax's exact doc structure for `tree_utils`)

**Action**:
1.  Open `docs/api/tree_utils.rst`.
2.  Add an `autofunction` directive for `optax.tree_utils.tree_random_split`. This ensures Sphinx picks up its docstring and signature.

**Pseudo-code**:
```rst
.. _api-tree-utils:

Tree Utilities
==============

.. automodule:: optax.tree_utils
   :members:
   :undoc-members:
   :show-inheritance:

.. autofunction:: optax.tree_utils.tree_random_split  <-- Add this line
```

### Step 6: Run Checks

After making all changes, run the tests and check for linting issues.

**Action**:
1.  Run all unit tests:
    ```bash
    bash test.sh
    ```
2.  Ensure no linting errors are introduced. Optax likely uses `black` and `isort`. You can typically run these tools to auto-format:
    ```bash
    black .
    isort .
    ```

## 4. Coding Style

*   **Readability**: Prioritize clear, readable code.
*   **Type Hinting**: All new code should be fully type-hinted.
*   **Docstrings**: Use Google-style docstrings for all public functions, classes, and methods.
*   **Formatting**: Adhere to `black` formatting and `isort` for imports.
*   **JAX Idioms**: Follow common JAX patterns, especially regarding `PRNGKey` handling and `PyTree` manipulations.

By following these steps, the `optax.tree_utils.tree_random_split` function will be successfully integrated into the Optax library, complete with tests and documentation.