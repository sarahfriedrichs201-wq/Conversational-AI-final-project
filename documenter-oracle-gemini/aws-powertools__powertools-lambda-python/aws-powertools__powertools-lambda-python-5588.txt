This document outlines the implementation plan for adding an exception handling mechanism to the `AppSyncResolver` in `aws_lambda_powertools`. The goal is to provide a decorator, `@app.exception_handler`, that allows developers to register custom functions to handle specific exception types raised during AppSync resolver execution, similar to the existing HTTP Resolver exception handling.

## Repository Overview

The `aws_lambda_powertools` repository provides a collection of utilities for AWS Lambda functions. The `event_handler` module contains classes like `AppSyncResolver` and `APIGatewayRestResolver` that simplify handling different event sources.

*   `aws_lambda_powertools/event_handler/appsync.py`: This is the primary file where the `AppSyncResolver` class resides and where the new exception handling logic will be implemented.
*   `examples/event_handler_graphql/src/`: This directory is suitable for adding a new example demonstrating the feature.
*   `tests/`: Unit and integration tests will be added here to ensure correctness and prevent regressions.
*   `CHANGELOG.md`: Will be updated to reflect the new feature.

The existing codebase follows PEP 8, uses type hints extensively, and includes comprehensive docstrings. New code should adhere to these standards.

## Implementation Plan

The implementation will involve modifying the `AppSyncResolver` class to store and dispatch exception handlers, and updating its `resolve` method to catch exceptions and invoke these handlers.

### 1. Modify `aws_lambda_powertools/event_handler/appsync.py`

#### 1.1. Add `_exception_handlers` attribute to `AppSyncResolver`

Initialize a dictionary within the `AppSyncResolver`'s `__init__` method to store registered exception handlers.

```python
# aws_lambda_powertools/event_handler/appsync.py

from typing import Any, Callable, Dict, List, Optional, Type, Union

class AppSyncResolver:
    _exception_handlers: Dict[Type[Exception], Callable[..., Any]] # Add this line

    def __init__(self, debug: Optional[bool] = None):
        # ... existing __init__ code ...
        self._exception_handlers = {} # Initialize the dictionary
```

#### 1.2. Implement `exception_handler` decorator

This decorator will allow users to register functions to handle specific exception types.

```python
# aws_lambda_powertools/event_handler/appsync.py

class AppSyncResolver:
    # ... existing code ...

    def exception_handler(self, exc_class: Union[Type[Exception], List[Type[Exception]]]) -> Callable:
        """
        Decorator to register a function as an exception handler for one or more exception types.

        Parameters
        ----------
        exc_class : Union[Type[Exception], List[Type[Exception]]]
            A single exception type or a list of exception types to handle.

        Returns
        -------
        Callable
            A decorator function that registers the exception handler.
        """
        def register_exception_handler(func: Callable[..., Any]) -> Callable[..., Any]:
            if not isinstance(exc_class, list):
                exception_types = [exc_class]
            else:
                exception_types = exc_class

            for ex_type in exception_types:
                if not issubclass(ex_type, Exception):
                    raise TypeError(f"'{ex_type.__name__}' is not an exception class.")
                self._exception_handlers[ex_type] = func
            return func
        return register_exception_handler
```

#### 1.3. Implement `_lookup_exception_handler` method

This private method will search for the most specific exception handler registered for a given exception type, considering its inheritance hierarchy.

```python
# aws_lambda_powertools/event_handler/appsync.py

class AppSyncResolver:
    # ... existing code ...

    def _lookup_exception_handler(self, exp_type: Type[Exception]) -> Optional[Callable[..., Any]]:
        """
        Looks up the registered exception handler for the given exception type or its base classes.

        It prioritizes the most specific handler (closest in the MRO).

        Parameters
        ----------
        exp_type : Type[Exception]
            The exception type to look up the handler for.

        Returns
        -------
        Optional[Callable[..., Any]]
            The registered exception handler function if found, otherwise None.
        """
        # Iterate through the Method Resolution Order (MRO) of the exception type
        for cls in exp_type.__mro__:
            if cls in self._exception_handlers:
                return self._exception_handlers[cls]
        return None
```

#### 1.4. Modify `resolve` method to catch and handle exceptions

The `resolve` method is the entry point for processing AppSync events. It needs to be updated to wrap the resolver function execution in a `try...except` block.

```python
# aws_lambda_powertools/event_handler/appsync.py

import asyncio
# ... other imports ...

class AppSyncResolver:
    # ... existing code ...

    def resolve(self, event: Dict[str, Any], context: LambdaContext) -> Any:
        # ... existing code ...

        try:
            # ... existing code to determine resolver_function and its arguments ...

            if asyncio.iscoroutinefunction(resolver_function):
                # NOTE: Exception handling is not supported for single async resolvers
                # This limitation is due to the current design of AppSyncResolver's async handling.
                # If the resolver_function is an async function, we directly await it.
                # If an exception occurs here, it will propagate as usual.
                # The problem description explicitly states this limitation.
                # If this limitation needs to be lifted in the future,
                # the async execution path would need a similar try/except block
                # and potentially a way to await the exception handler if it's async.
                return self._loop.run_until_complete(resolver_function(**args))
            else:
                # Synchronous resolver execution path
                return resolver_function(**args)
        except Exception as e:
            handler = self._lookup_exception_handler(type(e))
            if handler:
                # If a handler is found, call it with the exception instance
                # The handler's return value will be the response.
                return handler(e)
            else:
                # If no handler is found, re-raise the exception
                raise e
```

**Note on "single async resolvers" limitation**: As per the problem description, this exception handling mechanism is not supported for single async resolvers. The pseudo-code above reflects this by only applying the `try...except` block to the synchronous execution path. If `resolver_function` is an `async` function, the exception will propagate normally. This limitation should be clearly documented.

### 2. Create Example File: `examples/event_handler_graphql/src/exception_handling_graphql.py`

Create a new file to demonstrate the feature.

```python
# examples/event_handler_graphql/src/exception_handling_graphql.py

from aws_lambda_powertools.event_handler import AppSyncResolver
from aws_lambda_powertools.utilities.typing import LambdaContext

app = AppSyncResolver()

@app.exception_handler(ValueError)
def handle_value_error(ex: ValueError):
    """
    Handles ValueError exceptions raised by AppSync resolvers.
    Returns a custom error message.
    """
    # In a real application, you might log the exception,
    # transform it into a GraphQL error, or return a specific structure.
    print(f"Caught ValueError: {ex}")
    return {
        "message": "A value error occurred during processing.",
        "errorType": "ValueError",
        "details": str(ex)
    }

@app.exception_handler(Exception)
def handle_general_exception(ex: Exception):
    """
    Handles any other unhandled exceptions.
    This acts as a fallback handler.
    """
    print(f"Caught general Exception: {ex}")
    return {
        "message": "An unexpected error occurred.",
        "errorType": type(ex).__name__,
        "details": str(ex)
    }

@app.resolver(field_name="createSomething")
def create_something(id: str, name: str):
    """
    A sample AppSync resolver that raises a ValueError.
    """
    if not id:
        raise ValueError("ID cannot be empty.")
    if name == "fail":
        raise TypeError("Name cannot be 'fail' (simulated TypeError).") # This will be caught by handle_general_exception
    return {"id": id, "name": name, "status": "created"}

@app.resolver(field_name="getSomething")
def get_something(id: str):
    """
    A sample AppSync resolver that works normally.
    """
    return {"id": id, "name": f"Item {id}", "status": "retrieved"}

def lambda_handler(event: Dict[str, Any], context: LambdaContext) -> Dict[str, Any]:
    """
    Main Lambda handler function.
    """
    return app.resolve(event, context)

# Example usage (for local testing/understanding)
if __name__ == "__main__":
    # Simulate an AppSync event that triggers createSomething and raises ValueError
    event_value_error = {
        "arguments": {"id": "", "name": "test"},
        "info": {"fieldName": "createSomething"}
    }
    print("--- Testing ValueError ---")
    response_value_error = lambda_handler(event_value_error, {} as LambdaContext)
    print(response_value_error)
    # Expected output: {"message": "A value error occurred during processing.", "errorType": "ValueError", "details": "ID cannot be empty."}

    # Simulate an AppSync event that triggers createSomething and raises TypeError (caught by general handler)
    event_type_error = {
        "arguments": {"id": "123", "name": "fail"},
        "info": {"fieldName": "createSomething"}
    }
    print("\n--- Testing TypeError (general handler) ---")
    response_type_error = lambda_handler(event_type_error, {} as LambdaContext)
    print(response_type_error)
    # Expected output: {"message": "An unexpected error occurred.", "errorType": "TypeError", "details": "Name cannot be 'fail' (simulated TypeError)."}

    # Simulate a successful AppSync event
    event_success = {
        "arguments": {"id": "456"},
        "info": {"fieldName": "getSomething"}
    }
    print("\n--- Testing Success ---")
    response_success = lambda_handler(event_success, {} as LambdaContext)
    print(response_success)
    # Expected output: {"id": "456", "name": "Item 456", "status": "retrieved"}
```

### 3. Add Tests

#### 3.1. Unit Tests

Add unit tests in `tests/unit/event_handler/test_appsync.py` (or a new dedicated test file if preferred, e.g., `tests/unit/event_handler/test_appsync_exception_handler.py`).

```python
# tests/unit/event_handler/test_appsync.py (or new file)

import pytest
from unittest.mock import MagicMock
from aws_lambda_powertools.event_handler import AppSyncResolver
from aws_lambda_powertools.utilities.typing import LambdaContext

class CustomError(Exception):
    pass

def test_exception_handler_registers_single_exception():
    app = AppSyncResolver()
    mock_handler = MagicMock()

    @app.exception_handler(ValueError)
    def handler(ex: ValueError):
        mock_handler(ex)
        return {"error": "value"}

    assert ValueError in app._exception_handlers
    assert app._exception_handlers[ValueError] == handler

def test_exception_handler_registers_multiple_exceptions():
    app = AppSyncResolver()
    mock_handler = MagicMock()

    @app.exception_handler([ValueError, TypeError])
    def handler(ex: Exception):
        mock_handler(ex)
        return {"error": "multiple"}

    assert ValueError in app._exception_handlers
    assert TypeError in app._exception_handlers
    assert app._exception_handlers[ValueError] == handler
    assert app._exception_handlers[TypeError] == handler

def test_exception_handler_raises_type_error_for_non_exception_class():
    app = AppSyncResolver()
    with pytest.raises(TypeError, match="'int' is not an exception class."):
        @app.exception_handler(int)
        def handler(ex):
            pass

def test_lookup_exception_handler_finds_direct_match():
    app = AppSyncResolver()
    mock_handler = MagicMock()
    app._exception_handlers[ValueError] = mock_handler
    assert app._lookup_exception_handler(ValueError) == mock_handler

def test_lookup_exception_handler_finds_inherited_match():
    app = AppSyncResolver()
    mock_handler = MagicMock()
    app._exception_handlers[Exception] = mock_handler # Register for base Exception
    assert app._lookup_exception_handler(ValueError) == mock_handler # Should find handler for ValueError's base

def test_lookup_exception_handler_finds_most_specific_match():
    app = AppSyncResolver()
    general_handler = MagicMock(name="general_handler")
    value_error_handler = MagicMock(name="value_error_handler")
    app._exception_handlers[Exception] = general_handler
    app._exception_handlers[ValueError] = value_error_handler
    assert app._lookup_exception_handler(ValueError) == value_error_handler # Most specific
    assert app._lookup_exception_handler(TypeError) == general_handler # Falls back to general

def test_lookup_exception_handler_returns_none_if_no_match():
    app = AppSyncResolver()
    assert app._lookup_exception_handler(ValueError) is None

def test_resolve_calls_exception_handler_on_exception():
    app = AppSyncResolver()
    mock_context = MagicMock(spec=LambdaContext)
    mock_handler_return = {"message": "handled error"}

    @app.exception_handler(ValueError)
    def handler(ex: ValueError):
        return mock_handler_return

    @app.resolver(field_name="testField")
    def test_resolver():
        raise ValueError("Something went wrong")

    event = {"arguments": {}, "info": {"fieldName": "testField"}}
    result = app.resolve(event, mock_context)
    assert result == mock_handler_return

def test_resolve_re_raises_exception_if_no_handler():
    app = AppSyncResolver()
    mock_context = MagicMock(spec=LambdaContext)

    @app.resolver(field_name="testField")
    def test_resolver():
        raise CustomError("Unhandled error")

    event = {"arguments": {}, "info": {"fieldName": "testField"}}
    with pytest.raises(CustomError, match="Unhandled error"):
        app.resolve(event, mock_context)

def test_resolve_handles_multiple_exception_types_with_different_handlers():
    app = AppSyncResolver()
    mock_context = MagicMock(spec=LambdaContext)

    @app.exception_handler(ValueError)
    def value_handler(ex: ValueError):
        return {"errorType": "ValueError", "details": str(ex)}

    @app.exception_handler(TypeError)
    def type_handler(ex: TypeError):
        return {"errorType": "TypeError", "details": str(ex)}

    @app.resolver(field_name="valueErrorField")
    def value_error_resolver():
        raise ValueError("Invalid input")

    @app.resolver(field_name="typeErrorField")
    def type_error_resolver():
        raise TypeError("Wrong type")

    event_value = {"arguments": {}, "info": {"fieldName": "valueErrorField"}}
    result_value = app.resolve(event_value, mock_context)
    assert result_value == {"errorType": "ValueError", "details": "Invalid input"}

    event_type = {"arguments": {}, "info": {"fieldName": "typeErrorField"}}
    result_type = app.resolve(event_type, mock_context)
    assert result_type == {"errorType": "TypeError", "details": "Wrong type"}

def test_resolve_async_resolver_exception_not_handled(mocker):
    # This test verifies the explicit limitation for async resolvers
    app = AppSyncResolver()
    mock_context = MagicMock(spec=LambdaContext)
    mock_loop = mocker.patch("asyncio.get_event_loop")
    mock_loop.return_value.run_until_complete.side_effect = ValueError("Async error")

    @app.exception_handler(ValueError)
    def handler(ex: ValueError):
        return {"message": "handled error"}

    @app.resolver(field_name="asyncField")
    async def async_resolver():
        # This part won't be reached if run_until_complete raises
        pass

    event = {"arguments": {}, "info": {"fieldName": "asyncField"}}
    with pytest.raises(ValueError, match="Async error"):
        app.resolve(event, mock_context)
    # Assert that the exception handler was NOT called
    assert ValueError not in app._exception_handlers or app._exception_handlers[ValueError].call_count == 0

```

#### 3.2. Integration Tests (E2E)

If an E2E testing framework is in place (e.g., using `pytest` with `aws-cdk` or `aws-sam`), an integration test should be added. This would involve:

1.  Deploying the `exception_handling_graphql.py` example as a Lambda function behind an AppSync API.
2.  Invoking the AppSync API with a GraphQL query/mutation that triggers the `createSomething` resolver with an invalid `id` (e.g., `""`).
3.  Asserting that the AppSync response contains the custom error message returned by `handle_value_error`.
4.  Invoking with `name="fail"` to test the general exception handler.
5.  Invoking a successful resolver (`getSomething`) to ensure normal operation is unaffected.

This would typically involve creating a new infrastructure stack definition in `tests/e2e/` and a corresponding test file.

### 4. Update Documentation

#### 4.1. `CHANGELOG.md`

Add an entry under the `## Features` section for the next release.

```markdown
# Unreleased

## Features

*   **event_handler:** Add exception handling mechanism for AppSyncResolver ([#2184](https://github.com/aws-powertools/powertools-lambda-python/issues/2184))
```

#### 4.2. `README.md` (or relevant `docs/` files)

Update the documentation to include the new feature. This would typically be in `docs/core/event_handler/appsync.md` but since only `README.md` was provided, I'll assume it's the primary documentation.

*   Add a section under "Event handler: AppSync" describing the `@app.exception_handler` decorator.
*   Include the "User experience" code snippet provided in the problem description.
*   Clearly state the limitation: "This exception handling mechanism is not supported when using single async resolvers."

```markdown
# Powertools for AWS Lambda (Python)
...
## Features
...
*   **[Event handler: AppSync](https://docs.powertools.aws.dev/lambda/python/latest/core/event_handler/appsync/)** - AWS AppSync event handler for Lambda Direct Resolver and Amplify GraphQL Transformer function
    *   **Exception Handling**: Register custom handlers for exceptions raised within your AppSync resolvers using `@app.exception_handler`.
        ```python
        from aws_lambda_powertools.event_handler import AppSyncResolver

        app = AppSyncResolver()

        @app.exception_handler(ValueError)
        def handle_value_error(ex: ValueError):
            # Custom logic to format the error response
            return {"message": "error", "details": str(ex), "errorType": "ValueError"}

        @app.resolver(field_name="createSomething")
        def create_something(id: str):
            if not id:
                raise ValueError("ID cannot be empty")
            return {"id": id, "status": "created"}

        def lambda_handler(event, context):
            return app.resolve(event, context)
        ```
        **Note**: This exception handling mechanism is not supported when using single async resolvers.
...
```

## Review and Refinement

*   **Code Style**: Ensure all new code adheres to the existing project's black/ruff formatting, type hinting, and docstring conventions.
*   **Error Handling**: Consider edge cases for `_lookup_exception_handler` (e.g., what if `exc_class` is `None` or not an exception type? The `exception_handler` decorator already handles this for registration).
*   **Performance**: The lookup mechanism for exception handlers is a simple dictionary lookup and MRO traversal, which should have minimal performance impact.
*   **Clarity**: Ensure the documentation clearly explains how to use the feature and its limitations.
*   **Consistency**: Verify that the behavior aligns with how HTTP Resolvers handle exceptions, if applicable.

By following these steps, the new exception handling mechanism for `AppSyncResolver` can be implemented robustly and consistently with the existing codebase.