diff --git a/aws_lambda_powertools/event_handler/appsync.py b/aws_lambda_powertools/event_handler/appsync.py
--- a/aws_lambda_powertools/event_handler/appsync.py
+++ b/aws_lambda_powertools/event_handler/appsync.py
@@ -1,6 +1,7 @@
 import asyncio
 import logging
 from collections.abc import Callable
+from typing import Any
 
 from .api_gateway import Response
 from .exceptions import BadRequestError, InternalServerError, NotFoundError, ServiceError
@@ -8,6 +9,7 @@ from .graphql_appsync.router import Router
 from .graphql_appsync.types import (
     AppSyncResolverEvent,
     AppSyncResolverEventBatch,
+    InvalidBatchResponse,
 )
 
 logger = logging.getLogger(__name__)
@@ -15,6 +17,7 @@ logger = logging.getLogger(__name__)
 
 class AppSyncResolver(Router):
     """AppSync resolver for AWS Lambda Powertools"""
+
     current_event: AppSyncResolverEvent
     current_batch_event: AppSyncResolverEventBatch
 
@@ -22,6 +25,19 @@ class AppSyncResolver(Router):
         super().__init__()
         self._resolver_registry = ResolverRegistry()
 
+    def exception_handler(self, exc_class: type[Exception] | list[type[Exception]]) -> Callable:
+        """Decorator to register an exception handler for one or more exception types.
+
+        Example
+        -------
+        ```python
+        @app.exception_handler(ValueError)
+        def handle_value_error(ex: ValueError):
+            return {"message": "error"}
+        ```
+        """
+        return super().exception_handler(exc_class)
+
     def resolver(
         self,
         type_name: str | None = None,
@@ -116,7 +132,7 @@ class AppSyncResolver(Router):
         return self._call_single_resolver(event, AppSyncResolverEvent)
 
     def _call_single_resolver(self, event: dict, data_model: type[AppSyncResolverEvent]) -> Any:
-        """Call single event resolver"""
+        """Call single event resolver with exception handling."""
         logger.debug("Processing direct resolver event")
 
         self.current_event = data_model(event)
@@ -125,7 +141,15 @@ class AppSyncResolver(Router):
         if not resolver:
             raise ValueError(f"No resolver found for '{self.current_event.type_name}.{self.current_event.field_name}'")
 
-        return resolver["func"](**self.current_event.arguments)
+        try:
+            return resolver["func"](**self.current_event.arguments)
+        except Exception as exc:
+            # Check if this is an async coroutine (not supported for exception handling)
+            if asyncio.iscoroutinefunction(resolver["func"]):
+                raise
+
+            handler = self._lookup_exception_handler(exc)
+            return handler(exc) if handler else raise
 
     def resolve_batch(
         self,
@@ -154,7 +178,7 @@ class AppSyncResolver(Router):
         resolver: Callable,
         raise_on_error: bool = False,
         aggregate: bool = True,
-    ) -> list:
+    ) -> list[Any]:
         logger.debug(f"Graceful error handling flag {raise_on_error=}")
 
         # Checks whether the entire batch should be processed at once
@@ -164,7 +188,11 @@ class AppSyncResolver(Router):
                 response = resolver(event=self.current_batch_event)
                 if not isinstance(response, list):
                     raise InvalidBatchResponse("The response must be a List when using batch resolvers")
-                return response
+                return response
+            except Exception as exc:
+                handler = self._lookup_exception_handler(exc)
+                if handler:
+                    return [handler(exc)] * len(self.current_batch_event)
+                raise
 
             # Non aggregated events, process individually
             results = []
@@ -173,6 +201,12 @@ class AppSyncResolver(Router):
                     results.append(resolver(event=event, **event.arguments))
                 except Exception as exc:
                     logger.debug(f"Failed to process event number {idx} from field '{event.info.field_name}'")
+
+                    if raise_on_error:
+                        handler = self._lookup_exception_handler(exc)
+                        if handler:
+                            return [handler(exc)] * len(self.current_batch_event)
+                        raise
 
                     # Default graceful error handling
                     results.append(None)
@@ -184,7 +218,7 @@ class AppSyncResolver(Router):
         resolver: Callable,
         raise_on_error: bool = False,
         aggregate: bool = True,
-    ) -> list:
+    ) -> list[Any]:
         logger.debug(f"Graceful error handling flag {raise_on_error=}")
 
         # Checks whether the entire batch should be processed at once
@@ -194,7 +228,11 @@ class AppSyncResolver(Router):
                 ret = await resolver(event=self.current_batch_event)
                 if not isinstance(ret, list):
                     raise InvalidBatchResponse("The response must be a List when using batch resolvers")
-                return ret
+                return ret
+            except Exception as exc:
+                handler = self._lookup_exception_handler(exc)
+                if handler:
+                    return [handler(exc)] * len(self.current_batch_event)
+                raise
 
         response: list = []
 
@@ -204,7 +242,11 @@ class AppSyncResolver(Router):
         # Aggregate results or raise at first error
         if raise_on_error:
             try:
-                response.extend(await asyncio.gather(*tasks))
+                response.extend(await asyncio.gather(*tasks))
+                return response
+            except Exception as exc:
+                handler = self._lookup_exception_handler(exc)
+                if handler:
+                    return [handler(exc)] * len(self.current_batch_event)
                 raise
 
         # Aggregate results and exceptions, then filter them out
@@ -212,7 +254,10 @@ class AppSyncResolver(Router):
         for ret in results:
             if isinstance(ret, Exception):
                 logger.debug(f"Failed to process event due to {ret}")
-                response.append(None)
+                handler = self._lookup_exception_handler(ret)
+                if handler:
+                    response.append(handler(ret))
+                else:
+                    response.append(None)
             else:
                 response.append(ret)
 
diff --git a/aws_lambda_powertools/event_handler/graphql_appsync/router.py b/aws_lambda_powertools/event_handler/graphql_appsync/router.py
--- a/aws_lambda_powertools/event_handler/graphql_appsync/router.py
+++ b/aws_lambda_powertools/event_handler/graphql_appsync/router.py
@@ -1,6 +1,7 @@
 import logging
 from collections.abc import Callable
 from functools import wraps
+from typing import Any
 
 from ..exceptions import BadRequestError, InternalServerError, NotFoundError, ServiceError
 from .types import Resolver
@@ -10,6 +11,9 @@ logger = logging.getLogger(__name__)
 
 class Router:
     def __init__(self):
+        # Exception handler registry
+        self._exception_handlers: dict[type[Exception], Callable] = {}
+
         self._resolver_registry = ResolverRegistry()
 
     def resolver(
@@ -56,3 +60,26 @@ class Router:
             return resolver
 
         return decorator
+
+    def exception_handler(self, exc_class: type[Exception] | list[type[Exception]]) -> Callable:
+        """Decorator to register an exception handler for one or more exception types."""
+        def decorator(func: Callable) -> Callable:
+            if isinstance(exc_class, list):
+                for exc_type in exc_class:
+                    self._exception_handlers[exc_type] = func
+            else:
+                self._exception_handlers[exc_class] = func
+            return func
+        return decorator
+
+    def _lookup_exception_handler(self, exc: Exception) -> Callable | None:
+        """Find the most specific exception handler for the given exception.
+
+        Checks the exception's MRO (Method Resolution Order) to find the closest
+        matching handler in the inheritance hierarchy.
+        """
+        for exc_type in type(exc).__mro__:
+            if exc_type in self._exception_handlers:
+                return self._exception_handlers[exc_type]
+        return None
+
