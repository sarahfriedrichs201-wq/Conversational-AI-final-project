diff --git a/docs/api/utilities.rst b/docs/api/utilities.rst
--- a/docs/api/utilities.rst
+++ b/docs/api/utilities.rst
@@ -30,6 +30,7 @@
         tree_ones_like
         tree_random_like
         tree_random_split
+        tree_random_split
         tree_scalar_mul
         tree_set
         tree_sub
@@ -53,3 +54,7 @@
 Tree with random values
 ~~~~~~~~~~~~~~~~~~~~~~~
 .. autofunction:: tree_random_like
+
+Tree random split
+~~~~~~~~~~~~~~~~~
+.. autofunction:: tree_random_split
diff --git a/optax/tree_utils/__init__.py b/optax/tree_utils/__init__.py
--- a/optax/tree_utils/__init__.py
+++ b/optax/tree_utils/__init__.py
@@ -12,6 +12,7 @@
 # pylint: disable=g-importing-member
 from optax.tree_utils._casting import tree_cast
 from optax.tree_utils._random import tree_random_like
+from optax.tree_utils._random import tree_random_split
 from optax.tree_utils._state_utils import NamedTupleKey
 from optax.tree_utils._state_utils import State
 from optax.tree_utils._state_utils import StateDict
diff --git a/optax/tree_utils/_random.py b/optax/tree_utils/_random.py
--- a/optax/tree_utils/_random.py
+++ b/optax/tree_utils/_random.py
@@ -10,7 +10,29 @@
 from jax import tree_util as jtu
 
 
-def _tree_rng_keys_split(
+def tree_random_split(
+    rng_key: chex.PRNGKey, target_tree: chex.ArrayTree
+) -> chex.ArrayTree:
+  """Splits a PRNGKey into a PyTree of keys matching the target tree structure.
+
+  This function takes a single JAX PRNGKey and splits it into multiple keys,
+  distributing them across a PyTree structure that mirrors the `target_tree`.
+  Each leaf in the returned PyTree will be a unique PRNGKey derived from the
+  input `rng_key`.
+
+  Args:
+    rng_key: The JAX PRNGKey to split.
+    target_tree: The PyTree whose structure to match. Its leaves determine
+      the number of keys to split and the resulting tree structure.
+
+  Returns:
+    A PyTree of JAX PRNGKeys, with the same structure as `target_tree`.
+
+  .. versionadded:: 0.2.2
+  """
+  tree_def = jtu.tree_structure(target_tree)
+  keys = jax.random.split(rng_key, tree_def.num_leaves)
+  return jtu.tree_unflatten(tree_def, keys)
+
+
+def tree_random_like(
     rng_key: chex.PRNGKey,
     target_tree: chex.ArrayTree,
     sampler: Callable[
@@ -28,9 +50,7 @@
       The PyTree of random values.
   """
   # TODO(b/237207036): Consider adding a `seed` argument.
-  tree_def = jtu.tree_structure(target_tree)
-  keys = jax.random.split(rng_key, tree_def.num_leaves)
-  keys_tree = jtu.tree_unflatten(tree_def, keys)
+  keys_tree = tree_random_split(rng_key, target_tree)
   return jtu.tree_map(
       lambda l, k: sampler(k, l.shape, dtype or l.dtype),
       target_tree,
--- a/optax/tree_utils/_random.py
+++ b/optax/tree_utils/_random.py
@@ -10,7 +10,29 @@
 from jax import tree_util as jtu
 
 
-def _tree_rng_keys_split(
+def tree_random_split(
+    rng_key: chex.PRNGKey, target_tree: chex.ArrayTree
+) -> chex.ArrayTree:
+  """Splits a PRNGKey into a PyTree of keys matching the target tree structure.
+
+  This function takes a single JAX PRNGKey and splits it into multiple keys,
+  distributing them across a PyTree structure that mirrors the `target_tree`.
+  Each leaf in the returned PyTree will be a unique PRNGKey derived from the
+  input `rng_key`.
+
+  Args:
+    rng_key: The JAX PRNGKey to split.
+    target_tree: The PyTree whose structure to match. Its leaves determine
+      the number of keys to split and the resulting tree structure.
+
+  Returns:
+    A PyTree of JAX PRNGKeys, with the same structure as `target_tree`.
+
+  .. versionadded:: 0.2.2
+  """
+  tree_def = jtu.tree_structure(target_tree)
+  keys = jax.random.split(rng_key, tree_def.num_leaves)
+  return jtu.tree_unflatten(tree_def, keys)
+
+
+def tree_random_like(
     rng_key: chex.PRNGKey,
     target_tree: chex.ArrayTree,
     sampler: Callable[
@@ -28,9 +50,7 @@
       The PyTree of random values.
   """
   # TODO(b/237207036): Consider adding a `seed` argument.
-  tree_def = jtu.tree_structure(target_tree)
-  keys = jax.random.split(rng_key, tree_def.num_leaves)
-  keys_tree = jtu.tree_unflatten(tree_def, keys)
+  keys_tree = tree_random_split(rng_key, target_tree)
   return jtu.tree_map(
       lambda l, k: sampler(k, l.shape, dtype or l.dtype),
       target_tree,