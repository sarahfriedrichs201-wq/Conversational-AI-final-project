diff --git a/pgmpy/utils/utils.py b/pgmpy/utils/utils.py
--- a/pgmpy/utils/utils.py
+++ b/pgmpy/utils/utils.py
@@ -1,6 +1,9 @@
 import math
 from collections import defaultdict
 from itertools import combinations
+import pandas as pd
+import numpy as np
+from typing import Dict, List, Optional, Union
 
 
 def get_example_model(model_name="asia"):
@@ -107,3 +110,105 @@ def get_example_model(model_name="asia"):
     else:
         raise ValueError("No example model named: {model_name}".format(model_name=model_name))
 
+
+def discretize(data: pd.DataFrame, cardinality: Dict[str, int],
+               labels: Optional[Dict[str, List[str]]] = None,
+               method: str = "rounding") -> pd.DataFrame:
+    """
+    Discretizes a given continuous dataset.
+
+    Parameters
+    ----------
+    data: pandas.DataFrame
+        The dataset to discretize. All columns specified in `cardinality` must have continuous values.
+
+    cardinality: dict
+        A dictionary of the form (str: int) representing the number of bins
+        to create for each of the variables. Keys must correspond to column names in `data`.
+
+    labels: dict (default: None)
+        A dictionary of the form (str: list) representing the label names for
+        each variable in the discretized dataframe. If provided for a column,
+        the length of the list must match the `cardinality` for that column.
+        If None or an empty dict, default labels will be generated by pandas.
+
+    method: str (default: "rounding")
+        The discretization method to use.
+        - "rounding": Equal width bins are created using `pandas.cut`.
+        - "quantile": Bins are created such that each bin has an approximately equal number of datapoints,
+                      using `pandas.qcut`.
+
+    Examples
+    --------
+    >>> import numpy as np
+    >>> import pandas as pd
+    >>> from pgmpy.utils import discretize
+    >>> rng = np.random.default_rng(42)
+    >>> X = rng.standard_normal(1000)
+    >>> Y = 0.2 * X + rng.standard_normal(1000)
+    >>> Z = 0.4 * X + 0.5 * Y + rng.standard_normal(1000)
+    >>> df = pd.DataFrame({"X": X, "Y": Y, "Z": Z})
+    >>> df_disc = discretize(df, cardinality={'X': 3, 'Y': 3, 'Z': 3}, labels={'X': ['low', 'mid', 'high'], 'Y': ['low', 'mid', 'high'], 'Z': ['low', 'mid', 'high']})
+    >>> df_disc.head()
+        X    Y    Z
+    0   mid  mid  mid
+    1   mid  mid  low
+    2   mid  mid  mid
+    3  high  mid  mid
+    4   low  mid  low
+
+    Returns
+    -------
+    pandas.DataFrame: A discretized dataframe.
+    """
+    # Input Validation
+    if not isinstance(data, pd.DataFrame):
+        raise TypeError("Input 'data' must be a pandas.DataFrame.")
+    if data.empty:
+        return data.copy() # Return empty DataFrame if input is empty
+
+    if not isinstance(cardinality, dict):
+        raise TypeError("Input 'cardinality' must be a dictionary.")
+    if not cardinality:
+        raise ValueError("Input 'cardinality' cannot be empty.")
+
+    if labels is not None and not isinstance(labels, dict):
+        raise TypeError("Input 'labels' must be a dictionary or None.")
+
+    if method not in ["rounding", "quantile"]:
+        raise ValueError(f"Invalid method '{method}'. Must be 'rounding' or 'quantile'.")
+
+    # Ensure all columns in cardinality exist in data and are numeric
+    for col, num_bins in cardinality.items():
+        if col not in data.columns:
+            raise ValueError(f"Column '{col}' specified in 'cardinality' not found in 'data'.")
+        if not pd.api.types.is_numeric_dtype(data[col]):
+            raise TypeError(f"Column '{col}' must be numeric for discretization. Found type: {data[col].dtype}")
+        if not isinstance(num_bins, int) or num_bins <= 1:
+            raise ValueError(f"Cardinality for column '{col}' must be an integer greater than 1. Got {num_bins}.")
+
+    # Validate labels if provided
+    if labels:
+        for col, col_labels in labels.items():
+            if col not in cardinality:
+                # Optionally warn or ignore labels for columns not being discretized
+                # For now, let's raise an error for strictness.
+                raise ValueError(f"Labels provided for column '{col}' which is not in 'cardinality'.")
+            if not isinstance(col_labels, list):
+                raise TypeError(f"Labels for column '{col}' must be a list. Got {type(col_labels)}.")
+            if len(col_labels) != cardinality[col]:
+                raise ValueError(f"Length of labels for column '{col}' ({len(col_labels)}) must match cardinality ({cardinality[col]}).")
+
+    discretized_df = data.copy() # Work on a copy to avoid modifying the original DataFrame
+
+    for col, num_bins in cardinality.items():
+        col_labels = labels.get(col) if labels else None
+
+        if method == "rounding":
+            try:
+                discretized_df[col] = pd.cut(data[col], bins=num_bins, labels=col_labels, include_lowest=True)
+            except Exception as e:
+                raise ValueError(f"Error discretizing column '{col}' using 'rounding' method: {e}")
+
+        elif method == "quantile":
+            try:
+                discretized_df[col] = pd.qcut(data[col], q=num_bins, labels=col_labels, duplicates='drop')
+            except Exception as e:
+                raise ValueError(f"Error discretizing column '{col}' using 'quantile' method. "
+                                 f"This might happen if there are too few unique values for the requested number of quantiles. "
+                                 f"Original error: {e}")
+    return discretized_df
diff --git a/pgmpy/utils/__init__.py b/pgmpy/utils/__init__.py
--- a/pgmpy/utils/__init__.py
+++ b/pgmpy/utils/__init__.py
@@ -1,5 +1,6 @@
 from pgmpy.utils.utils import (
     get_example_model,
     # ... other utilities
+    discretize,
 )
diff --git a/pgmpy/tests/test_utils/test_utils.py b/pgmpy/tests/test_utils/test_utils.py
new file mode 100644
--- /dev/null
+++ b/pgmpy/tests/test_utils/test_utils.py
@@ -0,0 +1,123 @@
+import pytest
+import pandas as pd
+import numpy as np
+from pgmpy.utils import discretize
+
+class TestDiscretize:
+    def setup_method(self):
+        self.rng = np.random.default_rng(42)
+        self.X = self.rng.standard_normal(1000)
+        self.Y = 0.2 * self.X + self.rng.standard_normal(1000)
+        self.Z = 0.4 * self.X + 0.5 * self.Y + self.rng.standard_normal(1000)
+        self.df = pd.DataFrame({"X": self.X, "Y": self.Y, "Z": self.Z, "A": [1, 2, 3] * 333 + [1]})
+
+    def test_basic_rounding(self):
+        cardinality = {'X': 3, 'Y': 3}
+        df_disc = discretize(self.df, cardinality=cardinality, method="rounding")
+
+        assert isinstance(df_disc, pd.DataFrame)
+        assert df_disc.shape == self.df.shape
+        assert set(df_disc.columns) == set(self.df.columns)
+
+        # Check if specified columns are categorical
+        assert pd.api.types.is_categorical_dtype(df_disc['X'])
+        assert pd.api.types.is_categorical_dtype(df_disc['Y'])
+        # Check if non-specified columns are unchanged
+        assert pd.api.types.is_numeric_dtype(df_disc['Z'])
+        assert pd.api.types.is_numeric_dtype(df_disc['A'])
+
+        # Check number of categories
+        assert len(df_disc['X'].cat.categories) == 3
+        assert len(df_disc['Y'].cat.categories) == 3
+
+        # Check specific values (using the example from problem description)
+        # Re-run the example to get exact categories for comparison
+        df_example = pd.DataFrame({"X": self.X, "Y": self.Y, "Z": self.Z})
+        df_disc_example = discretize(df_example, cardinality={'X': 3, 'Y': 3, 'Z': 3}, labels={'X': ['low', 'mid', 'high'], 'Y': ['low', 'mid', 'high'], 'Z': ['low', 'mid', 'high']})
+
+        # Create expected head based on the example output
+        expected_head = pd.DataFrame({
+            'X': pd.Categorical(['mid', 'mid', 'mid', 'high', 'low'], categories=['low', 'mid', 'high']),
+            'Y': pd.Categorical(['mid', 'mid', 'mid', 'mid', 'mid'], categories=['low', 'mid', 'high']),
+            'Z': df_disc_example['Z'].head() # Z should be discretized in this example
+        })
+        pd.testing.assert_frame_equal(df_disc_example.head(), expected_head)
+
+    def test_basic_quantile(self):
+        cardinality = {'X': 4}
+        df_disc = discretize(self.df, cardinality=cardinality, method="quantile")
+
+        assert pd.api.types.is_categorical_dtype(df_disc['X'])
+        assert len(df_disc['X'].cat.categories) == 4
+
+    def test_with_labels(self):
+        cardinality = {'X': 2}
+        labels = {'X': ['group1', 'group2']}
+        df_disc = discretize(self.df, cardinality=cardinality, labels=labels)
+
+        assert list(df_disc['X'].cat.categories) == ['group1', 'group2']
+
+    def test_original_dataframe_unchanged(self):
+        original_df_copy = self.df.copy()
+        discretize(self.df, cardinality={'X': 3})
+        pd.testing.assert_frame_equal(self.df, original_df_copy)
+
+    # --- Error Handling Tests ---
+    def test_invalid_data_type(self):
+        with pytest.raises(TypeError, match="Input 'data' must be a pandas.DataFrame."):
+            discretize(np.array([1, 2, 3]), cardinality={'X': 2})
+
+    def test_empty_cardinality(self):
+        with pytest.raises(ValueError, match="Input 'cardinality' cannot be empty."):
+            discretize(self.df, cardinality={})
+
+    def test_invalid_method(self):
+        with pytest.raises(ValueError, match="Invalid method 'invalid'. Must be 'rounding' or 'quantile'."):
+            discretize(self.df, cardinality={'X': 2}, method="invalid")
+
+    def test_column_not_in_data(self):
+        with pytest.raises(ValueError, match="Column 'NonExistent' specified in 'cardinality' not found in 'data'."):
+            discretize(self.df, cardinality={'NonExistent': 2})
+
+    def test_non_numeric_column(self):
+        df_mixed = self.df.copy()
+        df_mixed['str_col'] = ['a'] * len(df_mixed)
+        with pytest.raises(TypeError, match="Column 'str_col' must be numeric for discretization."):
+            discretize(df_mixed, cardinality={'str_col': 2})
+
+    def test_invalid_cardinality_value(self):
+        with pytest.raises(ValueError, match="Cardinality for column 'X' must be an integer greater than 1. Got 1."):
+            discretize(self.df, cardinality={'X': 1})
+        with pytest.raises(ValueError, match="Cardinality for column 'X' must be an integer greater than 1. Got 0."):
+            discretize(self.df, cardinality={'X': 0})
+        with pytest.raises(ValueError, match="Cardinality for column 'X' must be an integer greater than 1. Got 2.5."):
+            discretize(self.df, cardinality={'X': 2.5})
+
+    def test_labels_wrong_length(self):
+        cardinality = {'X': 3}
+        labels = {'X': ['low', 'high']} # Incorrect length
+        with pytest.raises(ValueError, match="Length of labels for column 'X' \\(2\\) must match cardinality \\(3\\)."):
+            discretize(self.df, cardinality=cardinality, labels=labels)
+
+    def test_labels_for_non_discretized_column(self):
+        cardinality = {'X': 2}
+        labels = {'Y': ['a', 'b']} # Y not in cardinality
+        with pytest.raises(ValueError, match="Labels provided for column 'Y' which is not in 'cardinality'."):
+            discretize(self.df, cardinality=cardinality, labels=labels)
+
+    def test_qcut_with_few_unique_values(self):
+        df_few_unique = pd.DataFrame({'A': [1, 1, 1, 2, 2, 3, 3, 3]})
+        cardinality = {'A': 4} # More bins than unique values
+        df_disc = discretize(df_few_unique, cardinality=cardinality, method="quantile")
+        # With duplicates='drop', it should still work, but might result in fewer categories
+        assert pd.api.types.is_categorical_dtype(df_disc['A'])
+        assert len(df_disc['A'].cat.categories) <= 4 # Should be 3 categories (1,2,3)
+
+    def test_empty_dataframe(self):
+        empty_df = pd.DataFrame(columns=['X', 'Y'])
+        cardinality = {'X': 2}
+        df_disc = discretize(empty_df, cardinality=cardinality)
+        pd.testing.assert_frame_equal(df_disc, empty_df)
+        assert df_disc.empty
diff --git a/CHANGELOG.md b/CHANGELOG.md
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,6 +1,7 @@
 ## [0.1.26] - 2024-08-09
 ### Added
 ...
+3. Adds a simple discretization method: `pgmpy.utils.discretize`.
 ...
 ### Changed
 ...