diff --git a/lark/visitors.py b/lark/visitors.py
--- a/lark/visitors.py
+++ b/lark/visitors.py
@@ -1,4 +1,5 @@
 import abc
+from collections import deque
 
 from lark.exceptions import VisitError
 from lark.utils import get_regexp_width, Py36
@@ -28,6 +29,39 @@
         """
         return self.visit_children(tree)
 
+    def visit_topdown(self, tree):
+        """
+        Visit the tree from top to bottom.
+        
+        This method performs a depth-first traversal starting from the root
+        and moving downward to the leaves. Each node is visited before its children.
+        
+        Args:
+            tree: The root node of the tree to visit
+            
+        Returns:
+            The transformed tree if visitor methods return new nodes,
+            otherwise returns the original tree.
+        """
+        # Stack for iterative DFS (pre-order traversal)
+        stack = [tree]
+        
+        while stack:
+            node = stack.pop()
+            
+            # Get the appropriate visitor method for this node type
+            f = getattr(self, node.data, self.__default__)
+            
+            # Call the visitor method
+            result = f(node)
+            
+            # Add children to stack in reverse order to maintain left-to-right traversal
+            if hasattr(node, 'children'):
+                # For Tree nodes
+                for child in reversed(node.children):
+                    stack.append(child)
+        return tree
+
 
 class Visitor_Recursive(Visitor):
     """Bottom-up visitor, recursive version.
@@ -39,6 +73,32 @@
     def visit(self, tree):
         return self._visit_tree(tree)
 
+    def visit_topdown(self, tree):
+        """
+        Visit the tree from top to bottom using recursion.
+        
+        Visits the tree in depth-first order, starting from the root and
+        moving downward to the leaves.
+        
+        Args:
+            tree: The root node of the tree to visit
+            
+        Returns:
+            The transformed tree (if methods return values)
+        """
+        # Get the appropriate visitor method for this node type
+        f = getattr(self, tree.data, self.__default__)
+        
+        # Call the visitor method on current node
+        result = f(tree)
+        
+        # Process children recursively
+        if hasattr(tree, 'children'):
+            # For Tree nodes
+            for child in tree.children:
+                if hasattr(child, 'data'):  # Tree node
+                    self.visit_topdown(child)
+        return result
 
     def _visit_tree(self, tree):
         children = list(self._visit_child(child) for child in tree.children)
diff --git a/tests/test_trees.py b/tests/test_trees.py
--- a/tests/test_trees.py
+++ b/tests/test_trees.py
@@ -1,3 +1,5 @@
+import pytest
+
 from lark import Lark, Tree
 from lark.visitors import *
 from lark.reconstruct import Reconstructor
@@ -200,3 +202,85 @@
     assert reconstructor.reconstruct(tree) == 'a(b, c)'
     assert reconstructor.reconstruct(tree2) == 'a(b, c)'
     assert reconstructor.reconstruct(tree3) == 'a(b, c)'
+
+
+def test_visitor_topdown():
+    """Test top-down traversal for Visitor class"""
+    from lark.tree import Tree
+    from lark.visitors import Visitor
+    
+    class TestVisitor(Visitor):
+        def __init__(self):
+            self.visited = []
+            
+        def __default__(self, tree):
+            self.visited.append(tree.data)
+    
+    # Test tree structure
+    tree = Tree("a", [
+        Tree("b", [
+            Tree("c", []),
+            Tree("d", [])
+        ]),
+        Tree("e", [
+            Tree("f", []),
+            Tree("g", [])
+        ])
+    ])
+    
+    visitor = TestVisitor()
+    visitor.visit_topdown(tree)
+    
+    # Verify top-down order: a, b, c, d, e, f, g
+    expected = ['a', 'b', 'c', 'd', 'e', 'f', 'g']
+    assert visitor.visited == expected, f"Expected {expected}, got {visitor.visited}"
+
+
+def test_visitor_recursive_topdown():
+    """Test top-down traversal for Visitor_Recursive class"""
+    from lark.tree import Tree
+    from lark.visitors import Visitor_Recursive
+    
+    class TestVisitorRecursive(Visitor_Recursive):
+        def __init__(self):
+            self.visited = []
+            
+        def __default__(self, tree):
+            self.visited.append(tree.data)
+    
+    # Test tree structure (same as above for consistency)
+    tree = Tree("a", [
+        Tree("b", [
+            Tree("c", []),
+            Tree("d", [])
+        ]),
+        Tree("e", [
+            Tree("f", []),
+            Tree("g", [])
+        ])
+    ])
+    
+    visitor = TestVisitorRecursive()
+    visitor.visit_topdown(tree)
+    
+    # Verify top-down order: a, b, c, d, e, f, g
+    expected = ['a', 'b', 'c', 'd', 'e', 'f', 'g']
+    assert visitor.visited == expected, f"Expected {expected}, got {visitor.visited}"
+
+
+def test_visitor_topdown_with_return_values():
+    """Test that visit_topdown handles return values appropriately"""
+    from lark.tree import Tree
+    from lark.visitors import Visitor
+    
+    class TransformVisitor(Visitor):
+        def b(self, tree):
+            # Transform node 'b' to 'b_transformed'
+            return Tree('b_transformed', tree.children)
+            
+        def __default__(self, tree):
+            return tree
+    
+    tree = Tree("a", [Tree("b", [Tree("c", [])])])
+    visitor = TransformVisitor()
+    result = visitor.visit_topdown(tree)