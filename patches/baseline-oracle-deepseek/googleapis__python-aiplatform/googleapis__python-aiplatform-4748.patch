diff --git a/samples/model-builder/vector_search/vector_search_find_neighbors_sample.py b/samples/model-builder/vector_search/vector_search_find_neighbors_sample.py
--- a/samples/model-builder/vector_search/vector_search_find_neighbors_sample.py
+++ b/samples/model-builder/vector_search/vector_search_find_neighbors_sample.py
@@ -1,4 +1,4 @@
-# Copyright 2024 Google LLC
+# Copyright 2025 Google LLC
 #
 # Licensed under the Apache License, Version 2.0 (the "License");
 # you may not use this file except in compliance with the License.
@@ -12,7 +12,7 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
-"""Sample for find_neighbors using vector search."""
+"""Sample for find_neighbors using vector search including hybrid queries, filtering, and crowding."""
 
 from typing import List
 
@@ -63,6 +63,64 @@
     return matches
 
 
+# [START aiplatform_sdk_vector_search_find_neighbors_hybrid_sample]
+def vector_search_find_neighbors_hybrid_queries(
+    project: str,
+    location: str,
+    index_endpoint_name: str,
+    deployed_index_id: str,
+    num_neighbors: int,
+) -> List[
+    List[aiplatform.matching_engine.matching_engine_index_endpoint.MatchNeighbor]
+]:
+    """Query the vector search index using example hybrid queries.
+
+    Args:
+        project (str): Required. Project ID
+        location (str): Required. The region name
+        index_endpoint_name (str): Required. Index endpoint to run the query
+            against.
+        deployed_index_id (str): Required. The ID of the DeployedIndex to run
+            the queries against.
+        num_neighbors (int): Required. The number of neighbors to return.
+
+    Returns:
+        List[List[aiplatform.matching_engine.matching_engine_index_endpoint.MatchNeighbor]] - A list of nearest neighbors for each query.
+    """
+    # Initialize the Vertex AI client
+    aiplatform.init(project=project, location=location)
+
+    # Get the index endpoint
+    index_endpoint = aiplatform.MatchingEngineIndexEndpoint(
+        index_endpoint_name=index_endpoint_name
+    )
+
+    # Example hybrid queries: each query can have both sparse and dense embeddings
+    # For demonstration, we create one query with sparse and dense components
+    sparse_embeddings = [
+        aiplatform.matching_engine.matching_engine_index_endpoint.SparseEmbedding(
+            id="sparse_query_1",
+            # Sparse embedding represented as a dictionary of dimension index to value
+            # Example: {0: 0.5, 10: 0.3, 100: 0.8}
+            values={0: 0.5, 10: 0.3, 100: 0.8},
+        )
+    ]
+
+    dense_embeddings = [
+        # Example dense embedding vector
+        [0.1, 0.2, 0.3, 0.4, 0.5]
+    ]
+
+    # Perform hybrid search
+    matches = index_endpoint.find_neighbors(
+        deployed_index_id=deployed_index_id,
+        queries=dense_embeddings,
+        sparse_embeddings=sparse_embeddings,
+        num_neighbors=num_neighbors,
+    )
+    return matches
+# [END aiplatform_sdk_vector_search_find_neighbors_hybrid_sample]
+
+
 def vector_search_find_neighbors_batch(
     project: str,
     location: str,
@@ -127,3 +185,85 @@
         num_neighbors=num_neighbors,
     )
     return matches
+
+
+# [START aiplatform_sdk_vector_search_find_neighbors_filtering_crowding_sample]
+def vector_search_find_neighbors_filtering_crowding(
+    project: str,
+    location: str,
+    index_endpoint_name: str,
+    deployed_index_id: str,
+    queries: List[List[float]],
+    num_neighbors: int,
+    filter: List[
+        aiplatform.matching_engine.matching_engine_index_endpoint.Namespace
+    ],
+    numeric_filter: List[
+        aiplatform.matching_engine.matching_engine_index_endpoint.NumericNamespace
+    ],
+    per_crowding_attribute_neighbor_count: int,
+) -> List[
+    List[aiplatform.matching_engine.matching_engine_index_endpoint.MatchNeighbor]
+]:
+    """Query the vector search index with filtering and crowding.
+
+    Args:
+        project (str): Required. Project ID
+        location (str): Required. The region name
+        index_endpoint_name (str): Required. Index endpoint to run the query
+            against.
+        deployed_index_id (str): Required. The ID of the DeployedIndex to run
+            the queries against.
+        queries (List[List[float]]): Required. A list of queries. Each query is
+            a list of floats, representing a single embedding.
+        num_neighbors (int): Required. The number of neighbors to return.
+        filter (List[Namespace]): Required. A list of Namespaces for filtering
+            the matching results. For example,
+            [Namespace("color", ["red"], []), Namespace("shape", [], ["square"])]
+            will match datapoints that satisfy "red color" but not include
+            datapoints with "square shape".
+        numeric_filter (List[NumericNamespace]): Required. A list of
+            NumericNamespaces for filtering the matching results. For example,
+            [NumericNamespace(name="cost", value_int=5, op="GREATER")] will limit
+            the matching results to datapoints with cost greater than 5.
+        per_crowding_attribute_neighbor_count (int): Required. The maximum
+            number of returned matches with the same crowding tag.
+
+    Returns:
+        List[List[aiplatform.matching_engine.matching_engine_index_endpoint.MatchNeighbor]] - A list of nearest neighbors for each query.
+    """
+    # Initialize the Vertex AI client
+    aiplatform.init(project=project, location=location)
+
+    # Get the index endpoint
+    index_endpoint = aiplatform.MatchingEngineIndexEndpoint(
+        index_endpoint_name=index_endpoint_name
+    )
+
+    # Perform vector search with filtering and crowding
+    matches = index_endpoint.find_neighbors(
+        deployed_index_id=deployed_index_id,
+        queries=queries,
+        num_neighbors=num_neighbors,
+        filter=filter,
+        numeric_filter=numeric_filter,
+        per_crowding_attribute_neighbor_count=per_crowding_attribute_neighbor_count,
+    )
+    return matches
+# [END aiplatform_sdk_vector_search_find_neighbors_filtering_crowding_sample]
+
+
+if __name__ == "__main__":
+    # Example usage of the new functions
+    # Note: These are just examples and won't run without proper setup
+    # hybrid_matches = vector_search_find_neighbors_hybrid_queries(
+    #     project="your-project",
+    #     location="us-central1",
+    #     index_endpoint_name="your-index-endpoint",
+    #     deployed_index_id="your-deployed-index",
+    #     num_neighbors=10,
+    # )
+    # print(f"Hybrid search returned {len(hybrid_matches)} matches")
+    # For filtering and crowding sample, you would need to provide
+    # appropriate filter and numeric_filter arguments
+    pass